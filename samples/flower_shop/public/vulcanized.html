<!DOCTYPE html><html layout="" horizontal=""><head>
  <script src="bower_components/webcomponentsjs/webcomponents.js"></script>
  <script src="bower_components/underscore/underscore.js"></script>
  <script src="js/watch.js"></script>
  <style shim-shadowdom="">
/*******************************
          Flex Layout
*******************************/

html /deep/ [layout][horizontal], html /deep/ [layout][vertical] {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
}

html /deep/ [layout][horizontal][inline], html /deep/ [layout][vertical][inline] {
  display: -ms-inline-flexbox;
  display: -webkit-inline-flex;
  display: inline-flex;
}

html /deep/ [layout][horizontal] {
  -ms-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

html /deep/ [layout][horizontal][reverse] {
  -ms-flex-direction: row-reverse;
  -webkit-flex-direction: row-reverse;
  flex-direction: row-reverse;
}

html /deep/ [layout][vertical] {
  -ms-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

html /deep/ [layout][vertical][reverse] {
  -ms-flex-direction: column-reverse;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
}

html /deep/ [layout][wrap] {
  -ms-flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}

html /deep/ [layout][wrap-reverse] {
  -ms-flex-wrap: wrap-reverse;
  -webkit-flex-wrap: wrap-reverse;
  flex-wrap: wrap-reverse;
}

html /deep/ [flex] {
  -ms-flex: 1 1 0.000000001px;
  -webkit-flex: 1;
  flex: 1;
  -webkit-flex-basis: 0.000000001px;
  flex-basis: 0.000000001px;
}

html /deep/ [vertical][layout] > [flex][auto-vertical], html /deep/ [vertical][layout]::shadow [flex][auto-vertical] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html /deep/ [flex][auto] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html /deep/ [flex][none] {
  -ms-flex: none;
  -webkit-flex: none;
  flex: none;
}

html /deep/ [flex][one] {
  -ms-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

html /deep/ [flex][two] {
  -ms-flex: 2;
  -webkit-flex: 2;
  flex: 2;
}

html /deep/ [flex][three] {
  -ms-flex: 3;
  -webkit-flex: 3;
  flex: 3;
}

html /deep/ [flex][four] {
  -ms-flex: 4;
  -webkit-flex: 4;
  flex: 4;
}

html /deep/ [flex][five] {
  -ms-flex: 5;
  -webkit-flex: 5;
  flex: 5;
}

html /deep/ [flex][six] {
  -ms-flex: 6;
  -webkit-flex: 6;
  flex: 6;
}

html /deep/ [flex][seven] {
  -ms-flex: 7;
  -webkit-flex: 7;
  flex: 7;
}

html /deep/ [flex][eight] {
  -ms-flex: 8;
  -webkit-flex: 8;
  flex: 8;
}

html /deep/ [flex][nine] {
  -ms-flex: 9;
  -webkit-flex: 9;
  flex: 9;
}

html /deep/ [flex][ten] {
  -ms-flex: 10;
  -webkit-flex: 10;
  flex: 10;
}

html /deep/ [flex][eleven] {
  -ms-flex: 11;
  -webkit-flex: 11;
  flex: 11;
}

html /deep/ [flex][twelve] {
  -ms-flex: 12;
  -webkit-flex: 12;
  flex: 12;
}

/* alignment in cross axis */

html /deep/ [layout][start] {
  -ms-flex-align: start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

html /deep/ [layout][center], html /deep/ [layout][center-center] {
  -ms-flex-align: center;
  -webkit-align-items: center;
  align-items: center;
}

html /deep/ [layout][end] {
  -ms-flex-align: end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

/* alignment in main axis */

html /deep/ [layout][start-justified] {
  -ms-flex-pack: start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

html /deep/ [layout][center-justified], html /deep/ [layout][center-center] {
  -ms-flex-pack: center;
  -webkit-justify-content: center;
  justify-content: center;
}

html /deep/ [layout][end-justified] {
  -ms-flex-pack: end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

html /deep/ [layout][around-justified] {
  -ms-flex-pack: distribute;
  -webkit-justify-content: space-around;
  justify-content: space-around;
}

html /deep/ [layout][justified] {
  -ms-flex-pack: justify;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

/* self alignment */

html /deep/ [self-start] {
  -ms-align-self: flex-start;
  -webkit-align-self: flex-start;
  align-self: flex-start;
}

html /deep/ [self-center] {
  -ms-align-self: center;
  -webkit-align-self: center;
  align-self: center;
}

html /deep/ [self-end] {
  -ms-align-self: flex-end;
  -webkit-align-self: flex-end;
  align-self: flex-end;
}

html /deep/ [self-stretch] {
  -ms-align-self: stretch;
  -webkit-align-self: stretch;
  align-self: stretch;
}

/*******************************
          Other Layout
*******************************/

html /deep/ [block] {
  display: block;
}

/* ie support for hidden */
html /deep/ [hidden] {
  display: none !important;
}

html /deep/ [relative] {
  position: relative;
}

html /deep/ [fit] {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

body[fullbleed] {
  margin: 0;
  height: 100vh;
}

/*******************************
            Other
*******************************/

html /deep/ [segment], html /deep/ segment {
  display: block;
  position: relative;
  -webkit-box-sizing: border-box;
  -ms-box-sizing: border-box;
  box-sizing: border-box;
  margin: 1em 0.5em;
  padding: 1em;
  background-color: white;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  border-radius: 5px 5px 5px 5px;
}

</style>

<script src="bower_components/polymer/polymer.js"></script>

  <script type="text/javascript">
!function(t,e){function a(t,a,i){var r=e.createEvent("CustomEvent");return r.initCustomEvent(t,!1,!0,a),i.dispatchEvent(r)}function i(e){var i=g.parseUrl(t.location.href,e.getAttribute("mode"));if(i.hash!==b.hash&&i.path===b.path&&i.search===b.search&&i.isHashPath===b.isHashPath)return d(i.hash),void 0;b=i;var n={path:i.path};if(a("state-change",n,e)){for(var s=e.firstElementChild;s;){if("APP-ROUTE"===s.tagName&&g.testRoute(s.getAttribute("path"),i.path,e.getAttribute("trailingSlash"),s.hasAttribute("regex")))return r(e,s,i),void 0;s=s.nextSibling}a("not-found",n,e)}}function r(t,e,i){if(e.hasAttribute("redirect"))return t.go(e.getAttribute("redirect"),{replace:!0}),void 0;var r={path:i.path,route:e,oldRoute:t.activeRoute};a("activate-route-start",r,t)&&a("activate-route-start",r,e)&&(t.previousRoute&&t.previousRoute.transitionAnimationInProgress&&l(t.previousRoute),t.activeRoute&&t.activeRoute.removeAttribute("active"),t.previousRoute=t.activeRoute,t.activeRoute=e,t.activeRoute.setAttribute("active","active"),e.hasAttribute("import")?n(t,e.getAttribute("import"),e,i,r):e.hasAttribute("element")?o(t,e.getAttribute("element"),e,i,r):e.firstElementChild&&"TEMPLATE"===e.firstElementChild.tagName&&h(t,e.firstElementChild,e,i,r))}function n(t,a,i,r,n){function o(){s(t,h,a,i,r,n)}var h;f.hasOwnProperty(a)?(h=e.querySelector('link[href="'+a+'"]'),h.import?o():h.addEventListener("load",o)):(f[a]=!0,h=e.createElement("link"),h.setAttribute("rel","import"),h.setAttribute("href",a),h.addEventListener("load",o),e.head.appendChild(h))}function s(t,e,a,i,r,n){i.hasAttribute("active")&&(i.hasAttribute("template")?h(t,e.import.querySelector("template"),i,r,n):o(t,i.getAttribute("element")||a.split("/").slice(-1)[0].replace(".html",""),i,r,n))}function o(t,a,i,r,n){var s=e.createElement(a),o=u(t,i,r,n);for(var h in o)o.hasOwnProperty(h)&&(s[h]=o[h]);c(t,s,r,n)}function h(t,a,i,r,n){var s;if("createInstance"in a){var o=u(t,i,r,n);s=a.createInstance(o)}else s=e.importNode(a.content,!0);c(t,s,r,n)}function u(t,e,i,r){var n=g.routeArguments(e.getAttribute("path"),i.path,i.search,e.hasAttribute("regex"),"auto"===t.getAttribute("typecast"));return(e.hasAttribute("bindRouter")||t.hasAttribute("bindRouter"))&&(n.router=t),r.model=n,a("before-data-binding",r,t),a("before-data-binding",r,r.route),r.model}function c(t,e,i,r){t.hasAttribute("core-animated-pages")&&r.route!==r.oldRoute||p(t.previousRoute),t.activeRoute.appendChild(e),t.hasAttribute("core-animated-pages")&&(t.coreAnimatedPages.selected=t.activeRoute.getAttribute("path"),t.previousRoute&&(t.previousRoute.transitionAnimationInProgress=!0)),i.hash&&!t.hasAttribute("core-animated-pages")&&d(i.hash),a("activate-route-end",r,t),a("activate-route-end",r,r.route)}function l(t){t&&(t.transitionAnimationInProgress=!1,t.getAttribute("active")||p(t))}function p(t){if(t)for(var e=t.firstChild;e;){var a=e;e=e.nextSibling,"TEMPLATE"!==a.tagName&&t.removeChild(a)}}function d(t){t&&setTimeout(function(){var a=e.querySelector("html /deep/ "+t)||e.querySelector('html /deep/ [name="'+t.substring(1)+'"]');a&&a.scrollIntoView&&a.scrollIntoView(!0)},0)}function v(t,e,a,i,r){var n=t[e],s=a[i];if("**"===n&&e===t.length-1)return!0;if("undefined"==typeof n||"undefined"==typeof s)return n===s;if(n===s||"*"===n||":"===n.charAt(0))return":"===n.charAt(0)&&"undefined"!=typeof r&&(r[n.substring(1)]=a[i]),v(t,e+1,a,i+1,r);if("**"===n)for(var o=i;o<a.length;o++)if(v(t,e+1,a,o,r))return!0;return!1}var g={},f={},m="ActiveXObject"in t,b={},A=Object.create(HTMLElement.prototype);A.util=g,e.registerElement("app-route",{prototype:Object.create(HTMLElement.prototype)}),A.attachedCallback=function(){"manual"!==this.getAttribute("init")&&this.init()},A.init=function(){var a=this;a.isInitialized||(a.isInitialized=!0,a.hasAttribute("trailingSlash")||a.setAttribute("trailingSlash","strict"),a.hasAttribute("mode")||a.setAttribute("mode","auto"),a.hasAttribute("typecast")||a.setAttribute("typecast","auto"),a.hasAttribute("core-animated-pages")&&(a.createShadowRoot(),a.coreAnimatedPages=e.createElement("core-animated-pages"),a.coreAnimatedPages.appendChild(e.createElement("content")),a.coreAnimatedPages.style.position="static",a.coreAnimatedPages.setAttribute("valueattr","path"),a.coreAnimatedPages.setAttribute("transitions",a.getAttribute("transitions")),a.shadowRoot.appendChild(a.coreAnimatedPages),a.coreAnimatedPages.addEventListener("core-animated-pages-transition-end",function(){l(a.previousRoute)})),a.stateChangeHandler=i.bind(null,a),t.addEventListener("popstate",a.stateChangeHandler,!1),m&&t.addEventListener("hashchange",a.stateChangeHandler,!1),i(a))},A.detachedCallback=function(){t.removeEventListener("popstate",this.stateChangeHandler,!1),m&&t.removeEventListener("hashchange",this.stateChangeHandler,!1)},A.go=function(a,i){"pushstate"!==this.getAttribute("mode")&&(a="#"+a),i&&i.replace===!0?t.history.replaceState(null,null,a):t.history.pushState(null,null,a);try{var r=new PopStateEvent("popstate",{bubbles:!1,cancelable:!1,state:{}});"dispatchEvent_"in t?t.dispatchEvent_(r):t.dispatchEvent(r)}catch(n){var s=e.createEvent("CustomEvent");s.initCustomEvent("popstate",!1,!1,{state:{}}),t.dispatchEvent(s)}},g.parseUrl=function(t,a){var i={isHashPath:"hash"===a};if("function"==typeof URL){var r=new URL(t);i.path=r.pathname,i.hash=r.hash,i.search=r.search}else{var n=e.createElement("a");n.href=t,i.path=n.pathname,"/"!==i.path.charAt(0)&&(i.path="/"+i.path),i.hash=n.hash,i.search=n.search}if("pushstate"!==a&&("#/"===i.hash.substring(0,2)?(i.isHashPath=!0,i.path=i.hash.substring(1)):"#!/"===i.hash.substring(0,3)?(i.isHashPath=!0,i.path=i.hash.substring(2)):i.isHashPath&&(i.path=0===i.hash.length?"/":i.hash.substring(1)),i.isHashPath)){i.hash="";var s=i.path.indexOf("#");-1!==s&&(i.hash=i.path.substring(s),i.path=i.path.substring(0,s));var o=i.path.indexOf("?");-1!==o&&(i.search=i.path.substring(o),i.path=i.path.substring(0,o))}return i},g.testRoute=function(t,e,a,i){return"ignore"===a&&("/"===e.slice(-1)&&(e=e.slice(0,-1)),"/"!==t.slice(-1)||i||(t=t.slice(0,-1))),i?g.testRegExString(t,e):t===e||"*"===t?!0:("/"!==t.charAt(0)&&(t="/**/"+t),v(t.split("/"),1,e.split("/"),1))},g.routeArguments=function(t,e,a,i,r){var n={};i||("/"!==t.charAt(0)&&(t="/**/"+t),v(t.split("/"),1,e.split("/"),1,n));var s=a.substring(1).split("&");1===s.length&&""===s[0]&&(s=[]);for(var o=0;o<s.length;o++){var h=s[o],u=h.split("=");n[u[0]]=u.splice(1,u.length-1).join("=")}if(r)for(var c in n)n[c]=g.typecast(n[c]);return n},g.typecast=function(t){return"true"===t?!0:"false"===t?!1:isNaN(t)||""===t||"0"===t.charAt(0)?decodeURIComponent(t):+t},g.testRegExString=function(t,e){if("/"!==t.charAt(0))return!1;t=t.slice(1);var a="";if("/"===t.slice(-1))t=t.slice(0,-1);else{if("/i"!==t.slice(-2))return!1;t=t.slice(0,-2),a="i"}return new RegExp(t,a).test(e)},e.registerElement("app-router",{prototype:A})}(window,document);
</script>









<!--
Supports sharing a JSONP-based JavaScript library.

    <core-shared-lib on-core-shared-lib-load="{{load}}" url="https://apis.google.com/js/plusone.js?onload=%%callback%%">

Multiple components can request a library using a `core-shared-lib` component and only one copy of that library will
loaded from the network.

Currently, the library must support JSONP to work as a shared-lib. 

Some libraries require a specific global function be defined. If this is the case, specify the `callbackName` property.

Where possible, you should use an HTML Import to load library dependencies. Rather than using this element,
create an import (`<link rel="import" href="lib.html">`) that wraps loading the .js file:

lib.html:

    <script src="lib.js"></script>

@group Polymer Core Elements
@element core-shared-lib
-->


<!--
Dynamically loads the legacy Google JavaScript API Loader (https://developers.google.com/loader/),
firing the `api-load` event when ready.

Any number of components can use `<google-jsapi>` elements, and the library will only be loaded once.

@element google-jsapi
@extends core-shared-lib
@homepage https://googlewebcomponents.github.io/google-apis
-->


<!--
`google-chart` encapsulates Google Charts as a web component, allowing you to easily visualize
data. From simple line charts to complex hierarchical tree maps, the chart element provides a
number of ready-to-use chart types.

    <google-chart
      type='pie'
      options='{"title": "Distribution of days in 2001Q1"}'
      cols='[{"label":"Month", "type":"string"}, {"label":"Days", "type":"number"}]'
      rows='[["Jan", 31],["Feb", 28],["Mar", 31]]'>
    </google-chart>

Height and width are specified as style attributes:

    google-chart {
      height: 300px;
      width: 50em;
    }

Data can be provided in one of three ways:

- Via the `cols` and `rows` attributes:

      cols='[{"label":"Mth", "type":"string"}, {"label":"Days", "type":"number"}]'
      rows='[["Jan", 31],["Feb", 28],["Mar", 31]]'

- Via the `data` attribute, passing in the data directly:

      data='[["Month", "Days"], ["Jan", 31], ["Feb", 28], ["Mar", 31]]'

- Via the `data` attribute, passing in the URL to a resource containing the
  data, in JSON format:

      data='http://example.com/chart-data.json'

@element google-chart
@status alpha
@homepage http://googlewebcomponents.github.io/google-chart
-->




<style shim-shadowdom="">/*
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

html /deep/ paper-shadow,
html /deep/ paper-animated-shadow {
  display: block;
  position: relative;
}

html /deep/ paper-shadow::shadow #shadow-bottom,
html /deep/ paper-shadow::shadow #shadow-top {
  border-radius: inherit;
  pointer-events: none;
}

html /deep/ paper-shadow::shadow #shadow-bottom[animated],
html /deep/ paper-shadow::shadow #shadow-top[animated] {
  transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
}

html /deep/ .paper-shadow-top-z-1 {
  box-shadow: none;
}

html /deep/ .paper-shadow-bottom-z-1 {
  box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.37);
}

html /deep/ .paper-shadow-top-z-2 {
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.2);
}

html /deep/ .paper-shadow-bottom-z-2 {
  box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.3);
}

html /deep/ .paper-shadow-top-z-3 {
  box-shadow: 0 11px 7px 0 rgba(0, 0, 0, 0.19);
}

html /deep/ .paper-shadow-bottom-z-3 {
  box-shadow: 0 13px 25px 0 rgba(0, 0, 0, 0.3);
}

html /deep/ .paper-shadow-top-z-4 {
  box-shadow: 0 14px 12px 0 rgba(0, 0, 0, 0.17);
}

html /deep/ .paper-shadow-bottom-z-4 {
  box-shadow: 0 20px 40px 0 rgba(0, 0, 0, 0.3);
}

html /deep/ .paper-shadow-top-z-5 {
  box-shadow: 0 17px 17px 0 rgba(0, 0, 0, 0.15);
}

html /deep/ .paper-shadow-bottom-z-5 {
  box-shadow: 0 27px 55px 0 rgba(0, 0, 0, 0.3);
}</style>












<script>

(function(scope) {

/**
  `Polymer.CoreResizable` and `Polymer.CoreResizer` are a set of mixins that can be used
  in Polymer elements to coordinate the flow of resize events between "resizers" (elements
  that control the size or hidden state of their children) and "resizables" (elements that
  need to be notified when they are resized or un-hidden by their parents in order to take
  action on their new measurements).

  Elements that perform measurement should add the `Core.Resizable` mixin to their 
  Polymer prototype definition and listen for the `core-resize` event on themselves.
  This event will be fired when they become showing after having been hidden,
  when they are resized explicitly by a `CoreResizer`, or when the window has been resized.
  Note, the `core-resize` event is non-bubbling.

  `CoreResizable`'s must manually call the `resizableAttachedHandler` from the element's
  `attached` callback and `resizableDetachedHandler` from the element's `detached`
  callback.

    @element CoreResizable
    @status beta
    @homepage github.io
*/

  scope.CoreResizable = {

    /**
     * User must call from `attached` callback
     *
     * @method resizableAttachedHandler
     */
    resizableAttachedHandler: function(cb) {
      cb = cb || this._notifyResizeSelf;
      this.async(function() {
        var detail = {callback: cb, hasParentResizer: false};
        this.fire('core-request-resize', detail);
        if (!detail.hasParentResizer) {
          this._boundWindowResizeHandler = cb.bind(this);
          // log('adding window resize handler', null, this);
          window.addEventListener('resize', this._boundWindowResizeHandler);
        }
      }.bind(this));
    },

    /**
     * User must call from `detached` callback
     *
     * @method resizableDetachedHandler
     */
    resizableDetachedHandler: function() {
      this.fire('core-request-resize-cancel', null, this, false);
      if (this._boundWindowResizeHandler) {
        window.removeEventListener('resize', this._boundWindowResizeHandler);
      }
    },

    // Private: fire non-bubbling resize event to self; returns whether
    // preventDefault was called, indicating that children should not
    // be resized
    _notifyResizeSelf: function() {
      return this.fire('core-resize', null, this, false).defaultPrevented;
    }

  };

/**
  `Polymer.CoreResizable` and `Polymer.CoreResizer` are a set of mixins that can be used
  in Polymer elements to coordinate the flow of resize events between "resizers" (elements
  that control the size or hidden state of their children) and "resizables" (elements that
  need to be notified when they are resized or un-hidden by their parents in order to take
  action on their new measurements).

  Elements that cause their children to be resized (e.g. a splitter control) or hide/show
  their children (e.g. overlay) should add the `Core.CoreResizer` mixin to their 
  Polymer prototype definition and then call `this.notifyResize()` any time the element
  resizes or un-hides its children.

  `CoreResizer`'s must manually call the `resizerAttachedHandler` from the element's
  `attached` callback and `resizerDetachedHandler` from the element's `detached`
  callback.

  Note: `CoreResizer` extends `CoreResizable`, and can listen for the `core-resize` event
  on itself if it needs to perform resize work on itself before notifying children.
  In this case, returning `false` from the `core-resize` event handler (or calling
  `preventDefault` on the event) will prevent notification of children if required.

  @element CoreResizer
  @extends CoreResizable
  @status beta
  @homepage github.io
*/

  scope.CoreResizer = Polymer.mixin({

    /**
     * User must call from `attached` callback
     *
     * @method resizerAttachedHandler
     */
    resizerAttachedHandler: function() {
      this.resizableAttachedHandler(this.notifyResize);
      this._boundResizeRequested = this._boundResizeRequested || this._handleResizeRequested.bind(this);
      var listener;
      if (this.resizerIsPeer) {
        listener = this.parentElement || (this.parentNode && this.parentNode.host);
        listener._resizerPeers = listener._resizerPeers || [];
        listener._resizerPeers.push(this);
      } else {
        listener = this;
      }
      listener.addEventListener('core-request-resize', this._boundResizeRequested);
      this._resizerListener = listener;
    },

    /**
     * User must call from `detached` callback
     *
     * @method resizerDetachedHandler
     */
    resizerDetachedHandler: function() {
      this.resizableDetachedHandler();
      this._resizerListener.removeEventListener('core-request-resize', this._boundResizeRequested);
    },

    /**
     * User should call when resizing or un-hiding children
     *
     * @method notifyResize
     */
    notifyResize: function() {
      // Notify self
      if (!this._notifyResizeSelf()) {
        // Notify requestors if default was not prevented
        var r = this.resizeRequestors;
        if (r) {
          for (var i=0; i<r.length; i++) {
            var ri = r[i];
            if (!this.resizerShouldNotify || this.resizerShouldNotify(ri.target)) {
              // log('notifying resize', null, ri.target, true);
              ri.callback.apply(ri.target);
              // logEnd();
            }
          }
        }
      }
    },

    /**
     * User should implement to introduce filtering when notifying children.
     * Generally, children that are hidden by the CoreResizer (e.g. non-active
     * pages) need not be notified during resize, since they will be notified
     * again when becoming un-hidden.
     *
     * Return `true` if CoreResizable passed as argument should be notified of
     * resize.
     *
     * @method resizeerShouldNotify
     * @param {Element} el
     */
     // resizeerShouldNotify: function(el) { }  // User to implement if needed

    /**
     * Set to `true` if the resizer is actually a peer to the elements it
     * resizes (e.g. splitter); in this case it will listen for resize requests
     * events from its peers on its parent.
     *
     * @property resizerIsPeer
     * @type Boolean
     * @default false
     */

    // Private: Handle requests for resize
    _handleResizeRequested: function(e) {
      var target = e.path[0];
      if ((target == this) || 
          (target == this._resizerListener) || 
          (this._resizerPeers && this._resizerPeers.indexOf(target) < 0)) {
        return;
      }
      // log('resize requested', target, this);
      if (!this.resizeRequestors) {
        this.resizeRequestors = [];
      }
      this.resizeRequestors.push({target: target, callback: e.detail.callback});
      target.addEventListener('core-request-resize-cancel', this._cancelResizeRequested.bind(this));
      e.detail.hasParentResizer = true;
      e.stopPropagation();
    },

    // Private: Handle cancellation requests for resize
    _cancelResizeRequested: function(e) {
      // Exit early if we're already out of the DOM (resizeRequestors will already be null)
      if (this.resizeRequestors) {
        for (var i=0; i<this.resizeRequestors.length; i++) {
          if (this.resizeRequestors[i].target == e.target) {
            // log('resizeCanceled', e.target, this);
            this.resizeRequestors.splice(i, 1);
            break;
          }
        }
      }
    }

  }, Polymer.CoreResizable);

  // function prettyName(el) {
  //   return el.localName + (el.id ? '#' : '') + el.id;
  // }

  // function log(what, from, to, group) {
  //   var args = [what];
  //   if (from) {
  //     args.push('from ' + prettyName(from));
  //   }
  //   if (to) {
  //     args.push('to ' + prettyName(to));
  //   }
  //   if (group) {
  //     console.group.apply(console, args);
  //   } else {
  //     console.log.apply(console, args);
  //   }
  // }

  // function logEnd() {
  //   console.groupEnd();
  // }

})(Polymer);

</script>


<!--
@element core-key-helper
-->



<!--
@element core-overlay-layer
-->


<!--
The `core-overlay` element displays overlayed on top of other content. It starts
out hidden and is displayed by setting its `opened` property to true.
A `core-overlay's` opened state can be toggled by calling the `toggle`
method.

The `core-overlay` will, by default, show/hide itself when it's opened. The 
`target` property may be set to another element to cause that element to 
be shown when the overlay is opened.

It's common to want a `core-overlay` to animate to its opened
position. The `core-overlay` element uses a `core-transition` to handle
animation. The default transition is `core-transition-fade` which 
causes the overlay to fade in when displayed. See 
<a href="../core-transition/">`core-transition`</a> for more
information about customizing a `core-overlay's` opening animation. The
`backdrop` property can be set to true to show a backdrop behind the overlay
that will darken the rest of the window.

An element that should close the `core-overlay` will automatically
do so if it's given the `core-overlay-toggle` attribute. This attribute
can be customized with the `closeAttribute` property. You can also use
`closeSelector` if more general matching is needed.

By default  `core-overlay` will close whenever the user taps outside it or
presses the escape key. This behavior can be turned off via the
`autoCloseDisabled` property.

    <core-overlay>
      <h2>Dialog</h2>
      <input placeholder="say something..." autofocus>
      <div>I agree with this wholeheartedly.</div>
      <button core-overlay-toggle>OK</button>
    </core-overlay>

`core-overlay` will automatically size and position itself according to the 
following rules. The overlay's size is constrained such that it does not
overflow the screen. This is done by setting maxHeight/maxWidth on the 
`sizingTarget`. If the `sizingTarget` already has a setting for one of these
properties, it will not be overridden. The overlay should
be positioned via css or imperatively using the `core-overlay-position` event.
If the overlay is not positioned vertically via setting `top` or `bottom`, it
will be centered vertically. The same is true horizontally via a setting to 
`left` or `right`. In addition, css `margin` can be used to provide some space
around the overlay. This can be used to ensure
that, for example, a drop shadow is always visible around the overlay.

@group Core Elements
@element core-overlay
@mixins Polymer.CoreResizer https://github.com/polymer/core-resizable
@homepage github.io
-->
<!--
Fired when the `core-overlay`'s `opened` property changes.

@event core-overlay-open
@param {Object} detail
@param {Object} detail.opened the opened state
-->
<!--
Fired when the `core-overlay` has completely opened.

@event core-overlay-open-completed
-->
<!--
Fired when the `core-overlay` has completely closed.

@event core-overlay-close-completed
-->
<!--
Fired when the `core-overlay` needs to position itself. Optionally, implement
in order to position an overlay via code. If the overlay was not otherwise
positioned, it's important to indicate how the overlay has been positioned by
setting the `dimensions.position` object. For example, if the overlay has been
positioned via setting `right` and `top`, set dimensions.position to an
object like this: `{v: 'top', h: 'right'}`.

@event core-overlay-position
@param {Object} detail
@param {Object} detail.target the overlay target
@param {Object} detail.sizingTarget the overlay sizing target
@param {Object} detail.opened the opened state
-->
<style>
  .core-overlay-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: black;
    opacity: 0;
    transition: opacity 0.2s;
  }

  .core-overlay-backdrop.core-opened {
    opacity: 0.6;
  }
</style>






























  
  <style>
    html {
      height: 100%;
    }
    body {
      height: 100%;
      display: block;
      background-color: #424242;
      margin: 0;
      padding: 0;
    }
    fl-layout {
      height: 100%;
      width: 100%;
    }

    /* Unfortunate side-effect of paper-dialog implementation
       is that it cannot be styled within the containing element.
       (Because it is moved out of the shadow DOM)
       So, we style here. Two sets of styles, one for Chrome
       (with /deep/ for shadow dom), and one for other browsers */
    #reportNameDialogWrapper{
      font-family: helvetica, sans-serif;
      text-align: center;
    }
    html /deep/ #reportNameDialogWrapper {
      font-family: helvetica, sans-serif;
      text-align: center;
    }
    paper-dialog h1 {
      margin: 0 0 10px 0;
    }
    html /deep/ paper-dialog /deep/ h1 {
      margin: 0 0 10px 0;
    }
    paper-dialog button {
      margin: 10px;
      width: 100px;
    }
    html /deep/ paper-dialog /deep/ button {
      margin: 10px;
      width: 100px;
    }
  </style>
</head>
<body><div hidden="">

<polymer-element name="core-xhr" hidden="" assetpath="bower_components/core-ajax/">

  <script>

    Polymer('core-xhr', {

      /**
       * Sends a HTTP request to the server and returns the XHR object.
       *
       * @method request
       * @param {Object} inOptions
       *    @param {String} inOptions.url The url to which the request is sent.
       *    @param {String} inOptions.method The HTTP method to use, default is GET.
       *    @param {boolean} inOptions.sync By default, all requests are sent asynchronously. To send synchronous requests, set to true.
       *    @param {Object} inOptions.params Data to be sent to the server.
       *    @param {Object} inOptions.body The content for the request body for POST method.
       *    @param {Object} inOptions.headers HTTP request headers.
       *    @param {String} inOptions.responseType The response type. Default is 'text'.
       *    @param {boolean} inOptions.withCredentials Whether or not to send credentials on the request. Default is false.
       *    @param {Object} inOptions.callback Called when request is completed.
       * @returns {Object} XHR object.
       */
      request: function(options) {
        var xhr = new XMLHttpRequest();
        var url = options.url;
        var method = options.method || 'GET';
        var async = !options.sync;
        //
        var params = this.toQueryString(options.params);
        if (params && method.toUpperCase() == 'GET') {
          url += (url.indexOf('?') > 0 ? '&' : '?') + params;
        }
        var xhrParams = this.isBodyMethod(method) ? (options.body || params) : null;
        //
        xhr.open(method, url, async);
        if (options.responseType) {
          xhr.responseType = options.responseType;
        }
        if (options.withCredentials) {
          xhr.withCredentials = true;
        }
        this.makeReadyStateHandler(xhr, options.callback);
        this.setRequestHeaders(xhr, options.headers);
        xhr.send(xhrParams);
        if (!async) {
          xhr.onreadystatechange(xhr);
        }
        return xhr;
      },
    
      toQueryString: function(params) {
        var r = [];
        for (var n in params) {
          var v = params[n];
          n = encodeURIComponent(n);
          r.push(v == null ? n : (n + '=' + encodeURIComponent(v)));
        }
        return r.join('&');
      },

      isBodyMethod: function(method) {
        return this.bodyMethods[(method || '').toUpperCase()];
      },
      
      bodyMethods: {
        POST: 1,
        PUT: 1,
        PATCH: 1,
        DELETE: 1
      },

      makeReadyStateHandler: function(xhr, callback) {
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            callback && callback.call(null, xhr.response, xhr);
          }
        };
      },

      setRequestHeaders: function(xhr, headers) {
        if (headers) {
          for (var name in headers) {
            xhr.setRequestHeader(name, headers[name]);
          }
        }
      }

    });

  </script>
  
</polymer-element>
<polymer-element name="core-ajax" hidden="" attributes="url handleAs auto params response error method headers body contentType withCredentials progress loading" assetpath="bower_components/core-ajax/">
<script>

  Polymer('core-ajax', {
    /**
     * Fired when a response is received.
     *
     * @event core-response
     */

    /**
     * Fired when an error is received.
     *
     * @event core-error
     */

    /**
     * Fired whenever a response or an error is received.
     *
     * @event core-complete
     */

    /**
     * The URL target of the request.
     *
     * @attribute url
     * @type string
     * @default ''
     */
    url: '',

    /**
     * Specifies what data to store in the `response` property, and
     * to deliver as `event.response` in `response` events.
     *
     * One of:
     *
     *    `text`: uses `XHR.responseText`.
     *
     *    `xml`: uses `XHR.responseXML`.
     *
     *    `json`: uses `XHR.responseText` parsed as JSON.
     *
     *    `arraybuffer`: uses `XHR.response`.
     *
     *    `blob`: uses `XHR.response`.
     *
     *    `document`: uses `XHR.response`.
     *
     * @attribute handleAs
     * @type string
     * @default 'text'
     */
    handleAs: '',

    /**
     * If true, automatically performs an Ajax request when either `url` or `params` changes.
     *
     * @attribute auto
     * @type boolean
     * @default false
     */
    auto: false,

    /**
     * Parameters to send to the specified URL, as JSON.
     *
     * @attribute params
     * @type string
     * @default ''
     */
    params: '',

    /**
     * The response for the current request, or null if it hasn't
     * completed yet or the request resulted in error.
     *
     * @attribute response
     * @type Object
     * @default null
     */
    response: null,

    /**
     * The error for the current request, or null if it hasn't
     * completed yet or the request resulted in success.
     *
     * @attribute error
     * @type Object
     * @default null
     */
    error: null,

    /**
     * Whether the current request is currently loading.
     *
     * @attribute loading
     * @type boolean
     * @default false
     */
    loading: false,

    /**
     * The progress of the current request.
     *
     * @attribute progress
     * @type {loaded: number, total: number, lengthComputable: boolean}
     * @default {}
     */
    progress: null,

    /**
     * The HTTP method to use such as 'GET', 'POST', 'PUT', or 'DELETE'.
     * Default is 'GET'.
     *
     * @attribute method
     * @type string
     * @default ''
     */
    method: '',

    /**
     * HTTP request headers to send.
     *
     * Example:
     *
     *     <core-ajax
     *         auto
     *         url="http://somesite.com"
     *         headers='{"X-Requested-With": "XMLHttpRequest"}'
     *         handleAs="json"
     *         on-core-response="{{handleResponse}}"></core-ajax>
     *
     * @attribute headers
     * @type Object
     * @default null
     */
    headers: null,

    /**
     * Optional raw body content to send when method === "POST".
     *
     * Example:
     *
     *     <core-ajax method="POST" auto url="http://somesite.com"
     *         body='{"foo":1, "bar":2}'>
     *     </core-ajax>
     *
     * @attribute body
     * @type Object
     * @default null
     */
    body: null,

    /**
     * Content type to use when sending data.
     *
     * @attribute contentType
     * @type string
     * @default 'application/x-www-form-urlencoded'
     */
    contentType: 'application/x-www-form-urlencoded',

    /**
     * Set the withCredentials flag on the request.
     *
     * @attribute withCredentials
     * @type boolean
     * @default false
     */
    withCredentials: false,

    /**
     * Additional properties to send to core-xhr.
     *
     * Can be set to an object containing default properties
     * to send as arguments to the `core-xhr.request()` method
     * which implements the low-level communication.
     *
     * @property xhrArgs
     * @type Object
     * @default null
     */
    xhrArgs: null,

    created: function() {
      this.progress = {};
    },

    ready: function() {
      this.xhr = document.createElement('core-xhr');
    },

    receive: function(response, xhr) {
      if (this.isSuccess(xhr)) {
        this.processResponse(xhr);
      } else {
        this.processError(xhr);
      }
      this.complete(xhr);
    },

    isSuccess: function(xhr) {
      var status = xhr.status || 0;
      return !status || (status >= 200 && status < 300);
    },

    processResponse: function(xhr) {
      var response = this.evalResponse(xhr);
      if (xhr === this.activeRequest) {
        this.response = response;
      }
      this.fire('core-response', {response: response, xhr: xhr});
    },

    processError: function(xhr) {
      var response = xhr.status + ': ' + xhr.responseText;
      if (xhr === this.activeRequest) {
        this.error = response;
      }
      this.fire('core-error', {response: response, xhr: xhr});
    },

    processProgress: function(progress, xhr) {
      if (xhr !== this.activeRequest) {
        return;
      }
      // We create a proxy object here because these fields
      // on the progress event are readonly properties, which
      // causes problems in common use cases (e.g. binding to
      // <paper-progress> attributes).
      var progressProxy = {
        lengthComputable: progress.lengthComputable,
        loaded: progress.loaded,
        total: progress.total
      }
      this.progress = progressProxy;
    },

    complete: function(xhr) {
      if (xhr === this.activeRequest) {
        this.loading = false;
      }
      this.fire('core-complete', {response: xhr.status, xhr: xhr});
    },

    evalResponse: function(xhr) {
      return this[(this.handleAs || 'text') + 'Handler'](xhr);
    },

    xmlHandler: function(xhr) {
      return xhr.responseXML;
    },

    textHandler: function(xhr) {
      return xhr.responseText;
    },

    jsonHandler: function(xhr) {
      var r = xhr.responseText;
      try {
        return JSON.parse(r);
      } catch (x) {
        console.warn('core-ajax caught an exception trying to parse response as JSON:');
        console.warn('url:', this.url);
        console.warn(x);
        return r;
      }
    },

    documentHandler: function(xhr) {
      return xhr.response;
    },

    blobHandler: function(xhr) {
      return xhr.response;
    },

    arraybufferHandler: function(xhr) {
      return xhr.response;
    },

    urlChanged: function() {
      if (!this.handleAs) {
        var ext = String(this.url).split('.').pop();
        switch (ext) {
          case 'json':
            this.handleAs = 'json';
            break;
        }
      }
      this.autoGo();
    },

    paramsChanged: function() {
      this.autoGo();
    },

    bodyChanged: function() {
      this.autoGo();
    },

    autoChanged: function() {
      this.autoGo();
    },

    // TODO(sorvell): multiple side-effects could call autoGo
    // during one micro-task, use a job to have only one action
    // occur
    autoGo: function() {
      if (this.auto) {
        this.goJob = this.job(this.goJob, this.go, 0);
      }
    },

    getParams: function(params) {
      params = this.params || params;
      if (params && typeof(params) == 'string') {
        params = JSON.parse(params);
      }
      return params;
    },

    /**
     * Performs an Ajax request to the specified URL.
     *
     * @method go
     */
    go: function() {
      var args = this.xhrArgs || {};
      // TODO(sjmiles): we may want XHR to default to POST if body is set
      args.body = this.body || args.body;
      args.params = this.getParams(args.params);
      args.headers = this.headers || args.headers || {};
      if (args.headers && typeof(args.headers) == 'string') {
        args.headers = JSON.parse(args.headers);
      }
      var hasContentType = Object.keys(args.headers).some(function (header) {
        return header.toLowerCase() === 'content-type';
      });
      // No Content-Type should be specified if sending `FormData`.  
      // The UA must set the Content-Type w/ a calculated  multipart boundary ID.
      if (args.body instanceof FormData) {
        delete args.headers['Content-Type'];
      } 
      else if (!hasContentType && this.contentType) {
        args.headers['Content-Type'] = this.contentType;
      }
      if (this.handleAs === 'arraybuffer' || this.handleAs === 'blob' ||
          this.handleAs === 'document') {
        args.responseType = this.handleAs;
      }
      args.withCredentials = this.withCredentials;
      args.callback = this.receive.bind(this);
      args.url = this.url;
      args.method = this.method;

      this.response = this.error = this.progress = null;
      this.activeRequest = args.url && this.xhr.request(args);
      if (this.activeRequest) {
        this.loading = true;
        var activeRequest = this.activeRequest;
        // IE < 10 doesn't support progress events.
        if ('onprogress' in activeRequest) {
          this.activeRequest.addEventListener(
              'progress',
              function(progress) {
                this.processProgress(progress, activeRequest);
              }.bind(this), false);
        } else {
          this.progress = {
            lengthComputable: false,
          }
        }
      }
      return this.activeRequest;
    },

    /**
     * Aborts the current active request if there is one and resets internal
     * state appropriately.
     *
     * @method abort
     */
    abort: function() {
      if (!this.activeRequest) return;
      this.activeRequest.abort();
      this.activeRequest = null;
      this.progress = {};
      this.loading = false;
    }

  });

</script>
</polymer-element>

<polymer-element name="core-shared-lib" attributes="url notifyEvent callbackName" assetpath="bower_components/core-shared-lib/">
<script>
(function() {
  
  Polymer('core-shared-lib',{
    
    notifyEvent: 'core-shared-lib-load',
    
    ready: function() {
      if (!this.url && this.defaultUrl) {
        this.url = this.defaultUrl;
      }
    },
    
    urlChanged: function() {
      require(this.url, this, this.callbackName);
    },
    
    provide: function() {
      this.async('notify');
    },
    
    notify: function() {
      this.fire(this.notifyEvent, arguments);
    }
    
  });

  var apiMap = {};
  
  function require(url, notifiee, callbackName) {
    // make hashable string form url
    var name = nameFromUrl(url);
    // lookup existing loader instance
    var loader = apiMap[name];
    // create a loader as needed
    if (!loader) {
      loader = apiMap[name] = new Loader(name, url, callbackName);
    }
    loader.requestNotify(notifiee);
  }
  
  function nameFromUrl(url) {
    return url.replace(/[\:\/\%\?\&\.\=\-\,]/g, '_') + '_api';
  }

  var Loader = function(name, url, callbackName) {
    this.instances = [];
    this.callbackName = callbackName;
    if (this.callbackName) {
      window[this.callbackName] = this.success.bind(this);
    } else {
      if (url.indexOf(this.callbackMacro) >= 0) {
        this.callbackName = name + '_loaded';
        window[this.callbackName] = this.success.bind(this);
        url = url.replace(this.callbackMacro, this.callbackName);
      } else {
        // TODO(sjmiles): we should probably fallback to listening to script.load
        throw 'core-shared-api: a %%callback%% parameter is required in the API url';
      }
    }
    //
    this.addScript(url);
  };
  
  Loader.prototype = {
    
    callbackMacro: '%%callback%%',
    loaded: false,
    
    addScript: function(src) {
      var script = document.createElement('script');
      script.src = src;
      script.onerror = this.error.bind(this);
      var s = document.querySelector('script');
      s.parentNode.insertBefore(script, s);
      this.script = script;
    },
    
    removeScript: function() {
      if (this.script.parentNode) {
        this.script.parentNode.removeChild(this.script);
      }
      this.script = null;
    },
    
    error: function() {
      this.cleanup();
    },
    
    success: function() {
      this.loaded = true;
      this.cleanup();
      this.result = Array.prototype.slice.call(arguments);
      this.instances.forEach(this.provide, this);
      this.instances = null;
    },
    
    cleanup: function() {
      delete window[this.callbackName];
    },

    provide: function(instance) {
      instance.notify(instance, this.result);
    },
    
    requestNotify: function(instance) {
      if (this.loaded) {
        this.provide(instance);
      } else {
        this.instances.push(instance);
      }
    }
    
  };
  
})();
</script>
</polymer-element>
<polymer-element name="google-jsapi" extends="core-shared-lib" assetpath="bower_components/google-apis/">
<script>
  Polymer('google-jsapi',{
    defaultUrl: 'https://www.google.com/jsapi?callback=%%callback%%',
		
		/**
		 * Fired when the API library is loaded and available.
		 * @event api-load
		 */
    notifyEvent: 'api-load',
		
		/**
		 * Wrapper for `google` API namespace.
		 * @property api
		 */
    get api() {
      return google;
    }
  });
</script>
</polymer-element>
<polymer-element name="google-chart" attributes="type width height options cols rows data" assetpath="bower_components/google-chart/">

  <template>
    <style>:host {
  display: block;
  margin: 0;
  padding: 0;
  width: 400px;
  height: 300px;
}

#chartdiv {
  width: 100%;
  height: 100%;
  min-width: 100%;
  min-height: 100%;
}
</style>
    <core-ajax id="ajax" handleas="json" url="{{data}}" on-core-response="{{externalDataLoaded}}"></core-ajax>
    <div id="chartdiv"></div>
    <google-jsapi on-api-load="{{readyForAction}}"></google-jsapi>
  </template>

  <script>
    (function() {
      'use strict';

      Polymer('google-chart',{
        /**
         * Fired when the graph is displayed.
         *
         * @event google-chart-render
         */


        /**
         * Sets the type of the chart.
         *
         * Should be one of:
         * - `area`, `bar`, `bubble`, `candlestick`, `column`, `combo`, `geo`,
         *   `histogram`, `line`, `pie`, `scatter`, `stepped-area`
         *
         * See <a href="https://google-developers.appspot.com/chart/interactive/docs/gallery">Google Visualization API reference (Chart Gallery)</a> for details.
         *
         * @attribute type
         * @type string
         */
        type: 'column',

        /**
         * Sets the options for the chart.
         *
         * Example:
         * <pre>{
         *   title: "Chart title goes here",
         *   hAxis: {title: "Categories"},
         *   vAxis: {title: "Values", minValue: 0, maxValue: 2},
         *   legend: "none"
         * };</pre>
         * See <a href="https://google-developers.appspot.com/chart/interactive/docs/gallery">Google Visualization API reference (Chart Gallery)</a>
         * for the options available to each chart type.
         *
         * @attribute options
         * @type object
         */
        options: null,

        /**
         * Sets the data columns for this object.
         *
         * When specifying data with `cols` you must also specify `rows`, and
         * not specify `data`.
         *
         * Example:
         * <pre>[{label: "Categories", type: "string"},
         *  {label: "Value", type: "number"}]</pre>
         * See <a href="https://google-developers.appspot.com/chart/interactive/docs/reference#DataTable_addColumn">Google Visualization API reference (addColumn)</a>
         * for column definition format.
         *
         * @attribute cols
         * @type array
         */
        cols: null,

        /**
         * Sets the data rows for this object.
         *
         * When specifying data with `rows` you must also specify `cols`, and
         * not specify `data`.
         *
         * Example:
         * <pre>[["Category 1", 1.0],
         *  ["Category 2", 1.1]]</pre>
         * See <a href="https://google-developers.appspot.com/chart/interactive/docs/reference#addrow">Google Visualization API reference (addRow)</a>
         * for row format.
         *
         * @attribute rows
         * @type array
         */
        rows: null,

        /**
         * Sets the entire dataset for this object.
         * Can be used to provide the data directly, or to provide a URL from
         * which to request the data.
         *
         * The data format can be a two-dimensional array or the DataTable format
         * expected by Google Charts.
         * See <a href="https://google-developers.appspot.com/chart/interactive/docs/reference#DataTable">Google Visualization API reference (DataTable constructor)</a>
         * for data table format details.
         *
         * When specifying data with `data` you must not specify `cols` or `rows`.
         *
         * Example:
         * <pre>[["Categories", "Value"],
         *  ["Category 1", 1.0],
         *  ["Category 2", 1.1]]</pre>
         *
         * @attribute data
         * @type array, object, or string
         */
        data: null,

        chartTypes: null,

        chartObject: null,

        isReady: false,

        canDraw: false,

        dataTable: null,

        created: function() {
          this.chartTypes = {};
          this.cols = [];
          this.data = [];
          this.options = {};
          this.rows = [];
          this.dataTable = null;
        },

        readyForAction: function(e, detail, sender) {
          google.load("visualization", "1", {
            packages: ['corechart'],
            callback: function() {
              this.isReady = true;
              this.loadChartTypes();
              this.loadData();
            }.bind(this)
          });
        },

        typeChanged: function() {
          // Invalidate current chart object.
          this.chartObject = null;
          this.loadData();
        },

        observe: {
          rows: 'loadData',
          cols: 'loadData',
          data: 'loadData'
        },

        /**
         * Draws the chart.
         *
         * Called automatically on first load and whenever one of the attributes
         * changes. Can be called manually to handle e.g. page resizes.
         *
         * @method drawChart
         * @return {Object} Returns null.
         */
        drawChart: function() {
          if (this.canDraw) {
            if (!this.options) {
              this.options = {};
            }
            if (!this.chartObject) {
              var chartClass = this.chartTypes[this.type];
              if (chartClass) {
                this.chartObject = new chartClass(this.$.chartdiv);
              }
            }
            if (this.chartObject) {
              google.visualization.events.addOneTimeListener(this.chartObject,
                  'ready', function() {
                      this.fire('google-chart-render');
                  }.bind(this));
              this.chartObject.draw(this.dataTable, this.options);
            } else {
              this.$.chartdiv.innerHTML = 'Undefined chart type';
            }
          }
          return null;
        },

        loadChartTypes: function() {
          this.chartTypes = {
            'area': google.visualization.AreaChart,
            'bar': google.visualization.BarChart,
            'bubble': google.visualization.BubbleChart,
            'candlestick': google.visualization.CandlestickChart,
            'column': google.visualization.ColumnChart,
            'combo': google.visualization.ComboChart,
            'geo': google.visualization.GeoChart,
            'histogram': google.visualization.Histogram,
            'line': google.visualization.LineChart,
            'pie': google.visualization.PieChart,
            'scatter': google.visualization.ScatterChart,
            'stepped-area': google.visualization.SteppedAreaChart
          };
        },

        loadData: function() {
          this.canDraw = false;
          if (this.isReady) {
            if (typeof this.data == 'string' || this.data instanceof String) {
              // Load data asynchronously, from external URL.
              this.$.ajax.go();
            } else {
              var dataTable = this.createDataTable();
              this.canDraw = true;
              if (dataTable) {
                this.dataTable = dataTable;
                this.drawChart();
              }
            }
          }
        },

        externalDataLoaded: function(e, detail, sender) {
          var dataTable = this.createDataTable(this.$.ajax.response);
          this.canDraw = true;
          this.dataTable = dataTable;
          this.drawChart();
        },

        createDataTable: function(data) {
          var dataTable = null;

          // If a data object was not passed to this function, default to the
          // chart's data attribute. Passing a data object is necessary for
          // cases when the data attribute is a URL pointing to an external
          // data source.
          if (!data) {
            data = this.data;
          }

          if (this.rows && this.rows.length > 0 && this.cols &&
              this.cols.length > 0) {
            // Create the data table from cols and rows.
            dataTable = new google.visualization.DataTable();
            dataTable.cols = this.cols;

            for (var i = 0; i < this.cols.length; i++) {
              dataTable.addColumn(this.cols[i]);
            }

            dataTable.addRows(this.rows);
          } else {
            // Create dataTable from the passed data or the data attribute.
            // Data can be in the form of raw DataTable data or a two dimensional
            // array.
            if (data.rows && data.cols) {
              dataTable = new google.visualization.DataTable(data);
            } else if (data.length > 0) {
              dataTable = google.visualization.arrayToDataTable(data);
            }
          }

          return dataTable;
        }
      });
    })();
  </script>

</polymer-element>

<polymer-element name="paper-shadow" assetpath="bower_components/paper-shadow/">

<template>

  <div id="shadow-bottom" fit="" animated?="[[animated]]" class="paper-shadow-bottom-z-[[z]]"></div>
  <div id="shadow-top" fit="" animated?="[[animated]]" class="paper-shadow-top-z-[[z]]"></div>

  <content></content>

</template>

<script>
  Polymer('paper-shadow',{

    publish: {

      /**
       * The z-depth of this shadow, from 0-5. Setting this property
       * after element creation has no effect. Use `setZ()` instead.
       *
       * @attribute z
       * @type number
       * @default 1
       */
      z: 1,

      /**
       * Set this to true to animate the shadow when setting a new
       * `z` value.
       *
       * @attribute animated
       * @type boolean
       * @default false
       */
      animated: false

    },

    /**
     * Set the z-depth of the shadow. This should be used after element
     * creation instead of setting the z property directly.
     *
     * @method setZ
     * @param {Number} newZ
     */
    setZ: function(newZ) {
      if (this.z !== newZ) {
        this.$['shadow-bottom'].classList.remove('paper-shadow-bottom-z-' + this.z);
        this.$['shadow-bottom'].classList.add('paper-shadow-bottom-z-' + newZ);
        this.$['shadow-top'].classList.remove('paper-shadow-top-z-' + this.z);
        this.$['shadow-top'].classList.add('paper-shadow-top-z-' + newZ);
        this.z = newZ;
      }
    }

  });
</script>
</polymer-element>

<polymer-element name="core-meta" attributes="label type" hidden="" assetpath="bower_components/core-meta/">
<script>

  (function() {
    
    var SKIP_ID = 'meta';
    var metaData = {}, metaArray = {};

    Polymer('core-meta', {
      
      /**
       * The type of meta-data.  All meta-data with the same type with be
       * stored together.
       * 
       * @attribute type
       * @type string
       * @default 'default'
       */
      type: 'default',
      
      alwaysPrepare: true,
      
      ready: function() {
        this.register(this.id);
      },
      
      get metaArray() {
        var t = this.type;
        if (!metaArray[t]) {
          metaArray[t] = [];
        }
        return metaArray[t];
      },
      
      get metaData() {
        var t = this.type;
        if (!metaData[t]) {
          metaData[t] = {};
        }
        return metaData[t];
      },
      
      register: function(id, old) {
        if (id && id !== SKIP_ID) {
          this.unregister(this, old);
          this.metaData[id] = this;
          this.metaArray.push(this);
        }
      },
      
      unregister: function(meta, id) {
        delete this.metaData[id || meta.id];
        var i = this.metaArray.indexOf(meta);
        if (i >= 0) {
          this.metaArray.splice(i, 1);
        }
      },
      
      /**
       * Returns a list of all meta-data elements with the same type.
       * 
       * @property list
       * @type array
       * @default []
       */
      get list() {
        return this.metaArray;
      },
      
      /**
       * Retrieves meta-data by ID.
       *
       * @method byId
       * @param {String} id The ID of the meta-data to be returned.
       * @returns Returns meta-data.
       */
      byId: function(id) {
        return this.metaData[id];
      }
      
    });
    
  })();
  
</script>
</polymer-element>
<polymer-element name="core-transition" extends="core-meta" assetpath="bower_components/core-transition/">
  
  <script>
    Polymer('core-transition', {
      
      type: 'transition',

      /**
       * Run the animation.
       *
       * @method go
       * @param {Node} node The node to apply the animation on
       * @param {Object} state State info
       */
      go: function(node, state) {
        this.complete(node);
      },

      /**
       * Set up the animation. This may include injecting a stylesheet,
       * applying styles, creating a web animations object, etc.. This
       *
       * @method setup
       * @param {Node} node The animated node
       */
      setup: function(node) {
      },

      /**
       * Tear down the animation.
       *
       * @method teardown
       * @param {Node} node The animated node
       */
      teardown: function(node) {
      },

      /**
       * Called when the animation completes. This function also fires the
       * `core-transitionend` event.
       *
       * @method complete
       * @param {Node} node The animated node
       */
      complete: function(node) {
        this.fire('core-transitionend', null, node);
      },

      /**
       * Utility function to listen to an event on a node once.
       *
       * @method listenOnce
       * @param {Node} node The animated node
       * @param {string} event Name of an event
       * @param {Function} fn Event handler
       * @param {Array} args Additional arguments to pass to `fn`
       */
      listenOnce: function(node, event, fn, args) {
        var self = this;
        var listener = function() {
          fn.apply(self, args);
          node.removeEventListener(event, listener, false);
        }
        node.addEventListener(event, listener, false);
      }

    });
  </script>
</polymer-element>


<polymer-element name="core-key-helper" assetpath="bower_components/core-overlay/">
  <script>
    Polymer('core-key-helper', {
      ENTER_KEY: 13,
      ESCAPE_KEY: 27
    });
  </script>
</polymer-element>

<polymer-element name="core-overlay-layer" assetpath="bower_components/core-overlay/">
<template>
  <style>
    :host {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1000;
      display: none;
    }

    :host(.core-opened) {
      display: block;
    }
  </style>
  <content></content>
</template>
<script>
(function() {

  Polymer('core-overlay-layer', {
    publish: {
      opened: false
    },
    openedChanged: function() {
      this.classList.toggle('core-opened', this.opened);
    },
    /**
     * Adds an element to the overlay layer
     */
    addElement: function(element) {
      if (!this.parentNode) {
        document.querySelector('body').appendChild(this);
      }
      if (element.parentNode !== this) {
        element.__contents = [];
        var ip$ = element.querySelectorAll('content');
        for (var i=0, l=ip$.length, n; (i<l) && (n = ip$[i]); i++) {
          this.moveInsertedElements(n);
          this.cacheDomLocation(n);
          n.parentNode.removeChild(n);
          element.__contents.push(n);
        }
        this.cacheDomLocation(element);
        this.updateEventController(element);
        var h = this.makeHost();
        h.shadowRoot.appendChild(element);
        element.__host = h;
      }
    },
    makeHost: function() {
      var h = document.createElement('overlay-host');
      h.createShadowRoot();
      this.appendChild(h);
      return h;
    },
    moveInsertedElements: function(insertionPoint) {
      var n$ = insertionPoint.getDistributedNodes();
      var parent = insertionPoint.parentNode;
      insertionPoint.__contents = [];
      for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {
        this.cacheDomLocation(n);
        this.updateEventController(n);
        insertionPoint.__contents.push(n);
        parent.appendChild(n);  
      }
    },
    updateEventController: function(element) {
      element.eventController = this.element.findController(element);
    },
    /**
     * Removes an element from the overlay layer
     */
    removeElement: function(element) {
      element.eventController = null;
      this.replaceElement(element);
      var h = element.__host;
      if (h) {
        h.parentNode.removeChild(h);
      }
    },
    replaceElement: function(element) {
      if (element.__contents) {
        for (var i=0, c$=element.__contents, c; (c=c$[i]); i++) {
          this.replaceElement(c);
        }
        element.__contents = null;
      }
      if (element.__parentNode) {
        var n = element.__nextElementSibling && element.__nextElementSibling 
            === element.__parentNode ? element.__nextElementSibling : null;
        element.__parentNode.insertBefore(element, n);
      }
    },
    cacheDomLocation: function(element) {
      element.__nextElementSibling = element.nextElementSibling;
      element.__parentNode = element.parentNode;
    }
  });
  
})();
</script>
</polymer-element>
<polymer-element name="core-overlay" assetpath="bower_components/core-overlay/">
<script>
(function() {

  Polymer('core-overlay',Polymer.mixin({

    publish: {
      /**
       * The target element that will be shown when the overlay is 
       * opened. If unspecified, the core-overlay itself is the target.
       *
       * @attribute target
       * @type Object
       * @default the overlay element
       */
      target: null,


      /**
       * A `core-overlay`'s size is guaranteed to be 
       * constrained to the window size. To achieve this, the sizingElement
       * is sized with a max-height/width. By default this element is the 
       * target element, but it can be specifically set to a specific element
       * inside the target if that is more appropriate. This is useful, for 
       * example, when a region inside the overlay should scroll if needed.
       *
       * @attribute sizingTarget
       * @type Object
       * @default the target element
       */
      sizingTarget: null,
    
      /**
       * Set opened to true to show an overlay and to false to hide it.
       * A `core-overlay` may be made initially opened by setting its
       * `opened` attribute.
       * @attribute opened
       * @type boolean
       * @default false
       */
      opened: false,

      /**
       * If true, the overlay has a backdrop darkening the rest of the screen.
       * The backdrop element is attached to the document body and may be styled
       * with the class `core-overlay-backdrop`. When opened the `core-opened`
       * class is applied.
       *
       * @attribute backdrop
       * @type boolean
       * @default false
       */    
      backdrop: false,

      /**
       * If true, the overlay is guaranteed to display above page content.
       *
       * @attribute layered
       * @type boolean
       * @default false
      */
      layered: false,
    
      /**
       * By default an overlay will close automatically if the user
       * taps outside it or presses the escape key. Disable this
       * behavior by setting the `autoCloseDisabled` property to true.
       * @attribute autoCloseDisabled
       * @type boolean
       * @default false
       */
      autoCloseDisabled: false,

      /**
       * By default an overlay will focus its target or an element inside
       * it with the `autoFocus` attribute. Disable this
       * behavior by setting the `autoFocusDisabled` property to true.
       * @attribute autoFocusDisabled
       * @type boolean
       * @default false
       */
      autoFocusDisabled: false,

      /**
       * This property specifies an attribute on elements that should
       * close the overlay on tap. Should not set `closeSelector` if this
       * is set.
       *
       * @attribute closeAttribute
       * @type string
       * @default "core-overlay-toggle"
       */
      closeAttribute: 'core-overlay-toggle',

      /**
       * This property specifies a selector matching elements that should
       * close the overlay on tap. Should not set `closeAttribute` if this
       * is set.
       *
       * @attribute closeSelector
       * @type string
       * @default ""
       */
      closeSelector: '',

      /**
       * The transition property specifies a string which identifies a 
       * <a href="../core-transition/">`core-transition`</a> element that 
       * will be used to help the overlay open and close. The default
       * `core-transition-fade` will cause the overlay to fade in and out.
       *
       * @attribute transition
       * @type string
       * @default 'core-transition-fade'
       */
      transition: 'core-transition-fade'

    },

    captureEventName: 'tap',
    targetListeners: {
      'tap': 'tapHandler',
      'keydown': 'keydownHandler',
      'core-transitionend': 'transitionend'
    },

    attached: function() {
      this.resizerAttachedHandler();
    },

    detached: function() {
      this.resizerDetachedHandler();
    },

    resizerShouldNotify: function() {
      return this.opened;
    },

    registerCallback: function(element) {
      this.layer = document.createElement('core-overlay-layer');
      this.keyHelper = document.createElement('core-key-helper');
      this.meta = document.createElement('core-transition');
      this.scrim = document.createElement('div');
      this.scrim.className = 'core-overlay-backdrop';
    },

    ready: function() {
      this.target = this.target || this;
      // flush to ensure styles are installed before paint
      Polymer.flush();
    },

    /** 
     * Toggle the opened state of the overlay.
     * @method toggle
     */
    toggle: function() {
      this.opened = !this.opened;
    },

    /** 
     * Open the overlay. This is equivalent to setting the `opened`
     * property to true.
     * @method open
     */
    open: function() {
      this.opened = true;
    },

    /** 
     * Close the overlay. This is equivalent to setting the `opened` 
     * property to false.
     * @method close
     */
    close: function() {
      this.opened = false;
    },

    domReady: function() {
      this.ensureTargetSetup();
    },

    targetChanged: function(old) {
      if (this.target) {
        // really make sure tabIndex is set
        if (this.target.tabIndex < 0) {
          this.target.tabIndex = -1;
        }
        this.addElementListenerList(this.target, this.targetListeners);
        this.target.style.display = 'none';
        this.target.__overlaySetup = false;
      }
      if (old) {
        this.removeElementListenerList(old, this.targetListeners);
        var transition = this.getTransition();
        if (transition) {
          transition.teardown(old);
        } else {
          old.style.position = '';
          old.style.outline = '';
        }
        old.style.display = '';
      }
    },

    transitionChanged: function(old) {
      if (!this.target) {
        return;
      }
      if (old) {
        this.getTransition(old).teardown(this.target);
      }
      this.target.__overlaySetup = false;
    },

    // NOTE: wait to call this until we're as sure as possible that target
    // is styled.
    ensureTargetSetup: function() {
      if (!this.target || this.target.__overlaySetup) {
        return;
      }
      if (!this.sizingTarget) {
        this.sizingTarget = this.target;
      }
      this.target.__overlaySetup = true;
      this.target.style.display = '';
      var transition = this.getTransition();
      if (transition) {
        transition.setup(this.target);
      }
      var style = this.target.style;
      var computed = getComputedStyle(this.target);
      if (computed.position === 'static') {
        style.position = 'fixed';
      }
      style.outline = 'none';
      style.display = 'none';
    },

    openedChanged: function() {
      this.transitioning = true;
      this.ensureTargetSetup();
      this.prepareRenderOpened();
      // async here to allow overlay layer to become visible.
      this.async(function() {
        this.target.style.display = '';
        // force layout to ensure transitions will go
        this.target.offsetWidth;
        this.renderOpened();
      });
      this.fire('core-overlay-open', this.opened);
    },

    // tasks which must occur before opening; e.g. making the element visible
    prepareRenderOpened: function() {
      if (this.opened) {
        addOverlay(this);
      }
      this.prepareBackdrop();
      // async so we don't auto-close immediately via a click.
      this.async(function() {
        if (!this.autoCloseDisabled) {
          this.enableElementListener(this.opened, document,
              this.captureEventName, 'captureHandler', true);
        }
      });
      this.enableElementListener(this.opened, window, 'resize',
          'resizeHandler');

      if (this.opened) {
        // force layout so SD Polyfill renders
        this.target.offsetHeight;
        this.discoverDimensions();
        // if we are showing, then take care when positioning
        this.preparePositioning();
        this.positionTarget();
        this.updateTargetDimensions();
        this.finishPositioning();
        if (this.layered) {
          this.layer.addElement(this.target);
          this.layer.opened = this.opened;
        }
      }
    },

    // tasks which cause the overlay to actually open; typically play an
    // animation
    renderOpened: function() {
      this.notifyResize();
      var transition = this.getTransition();
      if (transition) {
        transition.go(this.target, {opened: this.opened});
      } else {
        this.transitionend();
      }
      this.renderBackdropOpened();
    },

    // finishing tasks; typically called via a transition
    transitionend: function(e) {
      // make sure this is our transition event.
      if (e && e.target !== this.target) {
        return;
      }
      this.transitioning = false;
      if (!this.opened) {
        this.resetTargetDimensions();
        this.target.style.display = 'none';
        this.completeBackdrop();
        removeOverlay(this);
        if (this.layered) {
          if (!currentOverlay()) {
            this.layer.opened = this.opened;
          }
          this.layer.removeElement(this.target);
        }
      }
      this.fire('core-overlay-' + (this.opened ? 'open' : 'close') + 
          '-completed');
      this.applyFocus();
    },

    prepareBackdrop: function() {
      if (this.backdrop && this.opened) {
        if (!this.scrim.parentNode) {
          document.body.appendChild(this.scrim);
          this.scrim.style.zIndex = currentOverlayZ() - 1;
        }
        trackBackdrop(this);
      }
    },

    renderBackdropOpened: function() {
      if (this.backdrop && getBackdrops().length < 2) {
        this.scrim.classList.toggle('core-opened', this.opened);
      }
    },

    completeBackdrop: function() {
      if (this.backdrop) {
        trackBackdrop(this);
        if (getBackdrops().length === 0) {
          this.scrim.parentNode.removeChild(this.scrim);
        }
      }
    },

    preparePositioning: function() {
      this.target.style.transition = this.target.style.webkitTransition = 'none';
      this.target.style.transform = this.target.style.webkitTransform = 'none';
      this.target.style.display = '';
    },

    discoverDimensions: function() {
      if (this.dimensions) {
        return;
      }
      var target = getComputedStyle(this.target);
      var sizer = getComputedStyle(this.sizingTarget);
      this.dimensions = {
        position: {
          v: target.top !== 'auto' ? 'top' : (target.bottom !== 'auto' ?
            'bottom' : null),
          h: target.left !== 'auto' ? 'left' : (target.right !== 'auto' ?
            'right' : null),
          css: target.position
        },
        size: {
          v: sizer.maxHeight !== 'none',
          h: sizer.maxWidth !== 'none'
        },
        margin: {
          top: parseInt(target.marginTop) || 0,
          right: parseInt(target.marginRight) || 0,
          bottom: parseInt(target.marginBottom) || 0,
          left: parseInt(target.marginLeft) || 0
        }
      };
    },

    finishPositioning: function(target) {
      this.target.style.display = 'none';
      this.target.style.transform = this.target.style.webkitTransform = '';
      // force layout to avoid application of transform
      this.target.offsetWidth;
      this.target.style.transition = this.target.style.webkitTransition = '';
    },

    getTransition: function(name) {
      return this.meta.byId(name || this.transition);
    },

    getFocusNode: function() {
      return this.target.querySelector('[autofocus]') || this.target;
    },

    applyFocus: function() {
      var focusNode = this.getFocusNode();
      if (this.opened) {
        if (!this.autoFocusDisabled) {
          focusNode.focus();
        }
      } else {
        focusNode.blur();
        if (currentOverlay() == this) {
          console.warn('Current core-overlay is attempting to focus itself as next! (bug)');
        } else {
          focusOverlay();
        }
      }
    },

    positionTarget: function() {
      // fire positioning event
      this.fire('core-overlay-position', {target: this.target,
          sizingTarget: this.sizingTarget, opened: this.opened});
      if (!this.dimensions.position.v) {
        this.target.style.top = '0px';
      }
      if (!this.dimensions.position.h) {
        this.target.style.left = '0px';
      }
    },

    updateTargetDimensions: function() {
      this.sizeTarget();
      this.repositionTarget();
    },

    sizeTarget: function() {
      this.sizingTarget.style.boxSizing = 'border-box';
      var dims = this.dimensions;
      var rect = this.target.getBoundingClientRect();
      if (!dims.size.v) {
        this.sizeDimension(rect, dims.position.v, 'top', 'bottom', 'Height');
      }
      if (!dims.size.h) {
        this.sizeDimension(rect, dims.position.h, 'left', 'right', 'Width');
      }
    },

    sizeDimension: function(rect, positionedBy, start, end, extent) {
      var dims = this.dimensions;
      var flip = (positionedBy === end);
      var m = flip ? start : end;
      var ws = window['inner' + extent];
      var o = dims.margin[m] + (flip ? ws - rect[end] : 
          rect[start]);
      var offset = 'offset' + extent;
      var o2 = this.target[offset] - this.sizingTarget[offset];
      this.sizingTarget.style['max' + extent] = (ws - o - o2) + 'px';
    },

    // vertically and horizontally center if not positioned
    repositionTarget: function() {
      // only center if position fixed.      
      if (this.dimensions.position.css !== 'fixed') {
        return; 
      }
      if (!this.dimensions.position.v) {
        var t = (window.innerHeight - this.target.offsetHeight) / 2;
        t -= this.dimensions.margin.top;
        this.target.style.top = t + 'px';
      }

      if (!this.dimensions.position.h) {
        var l = (window.innerWidth - this.target.offsetWidth) / 2;
        l -= this.dimensions.margin.left;
        this.target.style.left = l + 'px';
      }
    },

    resetTargetDimensions: function() {
      if (!this.dimensions || !this.dimensions.size.v) {
        this.sizingTarget.style.maxHeight = '';  
        this.target.style.top = '';
      }
      if (!this.dimensions || !this.dimensions.size.h) {
        this.sizingTarget.style.maxWidth = '';  
        this.target.style.left = '';
      }
      this.dimensions = null;
    },

    tapHandler: function(e) {
      // closeSelector takes precedence since closeAttribute has a default non-null value.
      if (e.target &&
          (this.closeSelector && e.target.matches(this.closeSelector)) ||
          (this.closeAttribute && e.target.hasAttribute(this.closeAttribute))) {
        this.toggle();
      } else {
        if (this.autoCloseJob) {
          this.autoCloseJob.stop();
          this.autoCloseJob = null;
        }
      }
    },
    
    // We use the traditional approach of capturing events on document
    // to to determine if the overlay needs to close. However, due to 
    // ShadowDOM event retargeting, the event target is not useful. Instead
    // of using it, we attempt to close asynchronously and prevent the close
    // if a tap event is immediately heard on the target.
    // TODO(sorvell): This approach will not work with modal. For
    // this we need a scrim.
    captureHandler: function(e) {
      if (!this.autoCloseDisabled && (currentOverlay() == this)) {
        this.autoCloseJob = this.job(this.autoCloseJob, function() {
          this.close();
        });
      }
    },

    keydownHandler: function(e) {
      if (!this.autoCloseDisabled && (e.keyCode == this.keyHelper.ESCAPE_KEY)) {
        this.close();
        e.stopPropagation();
      }
    },

    /**
     * Extensions of core-overlay should implement the `resizeHandler`
     * method to adjust the size and position of the overlay when the 
     * browser window resizes.
     * @method resizeHandler
     */
    resizeHandler: function() {
      this.updateTargetDimensions();
    },

    // TODO(sorvell): these utility methods should not be here.
    addElementListenerList: function(node, events) {
      for (var i in events) {
        this.addElementListener(node, i, events[i]);
      }
    },

    removeElementListenerList: function(node, events) {
      for (var i in events) {
        this.removeElementListener(node, i, events[i]);
      }
    },

    enableElementListener: function(enable, node, event, methodName, capture) {
      if (enable) {
        this.addElementListener(node, event, methodName, capture);
      } else {
        this.removeElementListener(node, event, methodName, capture);
      }
    },

    addElementListener: function(node, event, methodName, capture) {
      var fn = this._makeBoundListener(methodName);
      if (node && fn) {
        Polymer.addEventListener(node, event, fn, capture);
      }
    },

    removeElementListener: function(node, event, methodName, capture) {
      var fn = this._makeBoundListener(methodName);
      if (node && fn) {
        Polymer.removeEventListener(node, event, fn, capture);
      }
    },

    _makeBoundListener: function(methodName) {
      var self = this, method = this[methodName];
      if (!method) {
        return;
      }
      var bound = '_bound' + methodName;
      if (!this[bound]) {
        this[bound] = function(e) {
          method.call(self, e);
        };
      }
      return this[bound];
    }

  }, Polymer.CoreResizer));

  // TODO(sorvell): This should be an element with private state so it can
  // be independent of overlay.
  // track overlays for z-index and focus managemant
  var overlays = [];
  function addOverlay(overlay) {
    var z0 = currentOverlayZ();
    overlays.push(overlay);
    var z1 = currentOverlayZ();
    if (z1 <= z0) {
      applyOverlayZ(overlay, z0);
    }
  }

  function removeOverlay(overlay) {
    var i = overlays.indexOf(overlay);
    if (i >= 0) {
      overlays.splice(i, 1);
      setZ(overlay, '');
    }
  }
  
  function applyOverlayZ(overlay, aboveZ) {
    setZ(overlay.target, aboveZ + 2);
  }
  
  function setZ(element, z) {
    element.style.zIndex = z;
  }

  function currentOverlay() {
    return overlays[overlays.length-1];
  }
  
  var DEFAULT_Z = 10;
  
  function currentOverlayZ() {
    var z;
    var current = currentOverlay();
    if (current) {
      var z1 = window.getComputedStyle(current.target).zIndex;
      if (!isNaN(z1)) {
        z = Number(z1);
      }
    }
    return z || DEFAULT_Z;
  }
  
  function focusOverlay() {
    var current = currentOverlay();
    // We have to be careful to focus the next overlay _after_ any current
    // transitions are complete (due to the state being toggled prior to the
    // transition). Otherwise, we risk infinite recursion when a transitioning
    // (closed) overlay becomes the current overlay.
    //
    // NOTE: We make the assumption that any overlay that completes a transition
    // will call into focusOverlay to kick the process back off. Currently:
    // transitionend -> applyFocus -> focusOverlay.
    if (current && !current.transitioning) {
      current.applyFocus();
    }
  }

  var backdrops = [];
  function trackBackdrop(element) {
    if (element.opened) {
      backdrops.push(element);
    } else {
      var i = backdrops.indexOf(element);
      if (i >= 0) {
        backdrops.splice(i, 1);
      }
    }
  }

  function getBackdrops() {
    return backdrops;
  }
})();
</script>
</polymer-element>

<polymer-element name="core-transition-css" extends="core-transition" attributes="transitionType" assetpath="bower_components/core-transition/">
<template>
  <style no-shim="">/* Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt */

:host(.core-transition) {
  outline: none;
  overflow: auto;
  opacity: 0;
  -webkit-transition: -webkit-transform 0.2s ease-in-out, opacity 0.2s ease-in;
  transition: transform 0.2s ease-in-out, opacity 0.2s ease-in;
}


:host(.core-transition.core-opened) {
  opacity: 1;
  -webkit-transform: translateZ(0);
  transform: translateZ(0);
}

:host(.core-transition-center) {
  -webkit-transform: scale(0.5);
  transform: scale(0.5);
}

:host(.core-transition-top) {
  -webkit-transform: translateY(-200%);
  transform: translateY(-200%);
}

:host(.core-transition-bottom) {
  -webkit-transform: translateY(200%);
  transform: translateY(200%);
}

:host(.core-transition-left) {
  -webkit-transform: translateX(-200%);
  transform: translateX(-200%);
}

:host(.core-transition-right) {
  -webkit-transform: translateX(200%);
  transform: translateX(200%);
}</style>
</template>
<script>

  Polymer('core-transition-css', {

    /**
     * The class that will be applied to all animated nodes.
     *
     * @attribute baseClass
     * @type string
     * @default "core-transition"
     */
    baseClass: 'core-transition',

    /**
     * The class that will be applied to nodes in the opened state.
     *
     * @attribute openedClass
     * @type string
     * @default "core-opened"
     */
    openedClass: 'core-opened',

    /**
     * The class that will be applied to nodes in the closed state.
     *
     * @attribute closedClass
     * @type string
     * @default "core-closed"
     */
    closedClass: 'core-closed',

    /**
     * Event to listen to for animation completion.
     *
     * @attribute completeEventName
     * @type string
     * @default "transitionEnd"
     */
    completeEventName: 'transitionend',

    publish: {
      /**
       * A secondary configuration attribute for the animation. The class
       * `<baseClass>-<transitionType` is applied to the animated node during
       * `setup`.
       *
       * @attribute transitionType
       * @type string
       */
      transitionType: null
    },

    registerCallback: function(element) {
      this.transitionStyle = element.templateContent().firstElementChild;
    },

    // template is just for loading styles, we don't need a shadowRoot
    fetchTemplate: function() {
      return null;
    },

    go: function(node, state) {
      if (state.opened !== undefined) {
        this.transitionOpened(node, state.opened);
      }
    },

    setup: function(node) {
      if (!node._hasTransitionStyle) {
        if (!node.shadowRoot) {
          node.createShadowRoot().innerHTML = '<content></content>';
        }
        this.installScopeStyle(this.transitionStyle, 'transition',
            node.shadowRoot);
        node._hasTransitionStyle = true;
      }
      node.classList.add(this.baseClass);
      if (this.transitionType) {
        node.classList.add(this.baseClass + '-' + this.transitionType);
      }
    },

    teardown: function(node) {
      node.classList.remove(this.baseClass);
      if (this.transitionType) {
        node.classList.remove(this.baseClass + '-' + this.transitionType);
      }
    },

    transitionOpened: function(node, opened) {
      this.listenOnce(node, this.completeEventName, function() {
        if (!opened) {
          node.classList.remove(this.closedClass);
        }
        this.complete(node);
      });
      node.classList.toggle(this.openedClass, opened);
      node.classList.toggle(this.closedClass, !opened);
    }

  });
</script>
</polymer-element>

<core-transition-css id="core-transition-fade"></core-transition-css>
<core-transition-css id="core-transition-center" transitiontype="center"></core-transition-css>
<core-transition-css id="core-transition-top" transitiontype="top"></core-transition-css>
<core-transition-css id="core-transition-bottom" transitiontype="bottom"></core-transition-css>
<core-transition-css id="core-transition-left" transitiontype="left"></core-transition-css>
<core-transition-css id="core-transition-right" transitiontype="right"></core-transition-css>
<polymer-element name="paper-dialog-base" extends="core-overlay" role="dialog" on-core-overlay-open="{{openAction}}" assetpath="bower_components/paper-dialog/">

<script>

  Polymer('paper-dialog-base',{

    publish: {

      /**
       * The title of the dialog.
       *
       * @attribute heading
       * @type string
       * @default ''
       */
      heading: '',

      /**
       * @attribute transition
       * @type string
       * @default ''
       */
      transition: '',

      /**
       * @attribute layered
       * @type boolean
       * @default true
       */
      layered: true
    },

    ready: function() {
      this.super();
      this.sizingTarget = this.$.scroller;
    },

    headingChanged: function(old) {
      var label = this.getAttribute('aria-label');
      if (!label || label === old) {
        this.setAttribute('aria-label', this.heading);
      }
    },

    openAction: function() {
      if (this.$.scroller.scrollTop) {
        this.$.scroller.scrollTop = 0;
      }
    }

  });

</script>

</polymer-element>
<polymer-element name="paper-dialog" extends="paper-dialog-base" role="dialog" layout="" vertical="" assetpath="bower_components/paper-dialog/">

<template>

  <style>
    :host {
      background: #fff;
      color: rgba(0, 0, 0, 0.87);
      margin: 32px;
      overflow: visible !important;
    }

    h1 {
      font-size: 20px;
    }

    #scroller {
      overflow: auto;
      box-sizing: border-box;
      padding: 24px;
    }
  </style>

  <paper-shadow z="3" fit=""></paper-shadow>

  <!-- need this because the host needs to be overflow: visible -->
  <div id="scroller" relative="" flex="" auto="">
    <template if="{{heading}}">
      <h1>{{heading}}</h1>
    </template>

    <content></content>
  </div>

</template>

<script>Polymer('paper-dialog');</script></polymer-element>

<polymer-element name="volatile-storage" assetpath="elements/">
  <script>
    Polymer('volatile-storage',{
      ready: function () {
        this.data = {};
      },
      getItem: function (name) {
        if (window.localStorage) {
          return localStorage.getItem(name);
        }
        return this.data[name];
        // return '[{"name":"1","element":"fl-sales-distribution","options":{"startDate":"2/3/2012","endDate":"2/7/2012","numberOfDays":5,"viewSold":true,"viewUnsold":false,"viewRecent":true,"viewRange":false,"includedProducts":["Tulip","Rose","Dandelion"]}},{"name":"2","element":"fl-sales-distribution","options":{"startDate":"2/3/2012","endDate":"2/7/2012","numberOfDays":5,"viewSold":true,"viewUnsold":false,"viewRecent":true,"viewRange":false,"includedProducts":["Tulip","Rose","Dandelion"]}},{"name":"3","element":"fl-sales-distribution","options":{"startDate":"2/3/2012","endDate":"2/7/2012","numberOfDays":5,"viewSold":true,"viewUnsold":false,"viewRecent":true,"viewRange":false,"includedProducts":["Tulip","Rose","Dandelion"]}}]';
      },
      setItem: function (name, value) {
        if (window.localStorage) {
          return localStorage.setItem(name, value);
        }
        return this.data[name] = value;
      }
    });
  </script>
</polymer-element>

<polymer-element name="fl-report-options" assetpath="elements/">
  <template>
    <style>
      :host {
        display: block;
        background-color: #EFEFEF;
        padding: 10px;
        font-family: helvita, sans-serif;
      }
      #titleBar > * {
        margin: 0 10px 0 10px;
      }
      h1 {
        font-size: 1.2em;
        padding-left: 15px;
        text-align: left;
      }
      h2 {
        margin: 0;
        font-size: 1em;
        text-align: center;
        border-bottom-style: solid;
        border-bottom-width: 1px;
        border-bottom-color: rgba(0, 0, 0, .3);
      }
      p {
        margin: 0;
      }
      fieldset {
        min-width: 150px;
        border-style: solid;
        border-width: 1px;
        border-color: rgba(0, 0, 0, .3);
        border-radius: 5px;
      }
      #inputs > * {
        margin: 5px;
        padding: 10px;
        min-width: 150px;
        margin: 5px;
        padding: 10px;
      }
      .inputGroup {
        border-style: solid;
        border-width: 1px;
        border-color: rgba(0, 0, 0, .3);
        border-radius: 5px;
      }
      .dateSelector {
        padding: 5px 0 0 0;
      }
      .dateSelector > label {
        min-width: 50px;
      }
      #timeSpanInputs {
        flex: 0 0 auto;
      }
      #refresh > img {
        width: 50px;
        height: 50px;
      }
    </style>

    <div id="titleBar" layout="" horizontal="" center="">
      <h1>{{label}}</h1>
      <content></content>
    </div>
    <div id="inputs" layout="" horizontal="">
      <div class="inputGroup" id="productSelectionGroup">
        <h2>Products</h2>
        <template repeat="{{ product in salesData.products }}">
          <label><input type="checkbox" name="{{product}}" on-change="{{toggleProduct}}">{{product}}</label><br>
        </template>
      </div>

      <div id="timeSpanInputs" class="inputGroup">
        <h2>Time Span</h2>
        <div layout="" horizontal="">
          <fieldset flex="">
            <legend>
              <label><input id="viewRecent" type="radio" checked="{{viewRecent}}">Most Recent</label>
            </legend>
            <select value="{{numberOfDays}}" disabled?="{{!viewRecent}}">
              <option template="" repeat="{{ i in [1, 2, 3, 4, 5]}}" value="{{i}}">{{i}}</option>
            </select> Days
          </fieldset>
          <fieldset>
            <legend>
              <label><input id="viewRange" type="radio" checked="{{viewRange}}">Range</label>
            </legend>
            <div class="dateSelector" layout="" horizontal="">
              <label>Start</label>
              <select id="selectStartDate" value="{{startDate}}" on-change="{{updateEndDateOptions}}" disabled?="{{!viewRange}}" flex="">
                  <option value="{{date}}" template="" repeat="{{date in dates}}">{{date}}</option>
              </select><br>
            </div>
            <div class="dateSelector" layout="" horizontal="">
              <label>End</label>
              <select id="selectEndDate" value="{{endDate}}" disabled?="{{!viewRange}}" flex="">
                <option value="{{date}}" template="" repeat="{{date in endDates}}">{{date}}</option>
              </select><br>
            </div>
          </fieldset>
        </div>
      </div>

      <div class="inputGroup" id="statSelection">
        <h2>View</h2>
        <label><input id="viewSold" type="radio" checked="{{viewSold}}">Items Sold</label><br>
        <label><input id="viewUnsold" type="radio" checked="{{viewUnsold}}">Items Unsold</label>
      </div>

      <button id="refresh" title="Refresh" on-click="{{onRefresh}}"><img src="images/refresh.svg"></button>
    </div>
  </template>

  <script>
    Polymer('fl-report-options',{
      publish: {
        startDate: '',
        endDate: '',
        viewRecent: true,
        numberOfDays: 5,
        viewRange: false,
        viewSold: true,
        viewUnsold: false,
        label: '',
        localStorageKey: '',

        // Use this to set ALL options as a json string
        options: ''
      },
      ready: function () {
        this.storage = document.getElementById('storage');

        this.salesData = window.salesData;

        this.dates = _.uniq(_.pluck(this.salesData.history, "date")).sort(function (date1, date2) {
          return Date.parse(date1) - Date.parse(date2);
        });
        this.endDates = this.dates;

        if (this.options) {
          if (typeof this.options == 'string' || this.options instanceof String) {
            Polymer.extend(this, JSON.parse(this.options));
          } else {
            Polymer.extend(this, this.options);
          }
        } else if (!this.localStorageKey ||
                   !this.localStorageKey.length > 0 ||
                   !this.loadSavedState()) {
          this.startDate = this.dates[0];
          this.endDate = this.dates[this.dates.length - 1];
          this.includedProducts = [];
          this.salesData.products.forEach(function (product) {
            this.includedProducts.push(product);
          }.bind(this));
        }

        mutualExclusion(this, ['viewRange', 'viewRecent']);
        mutualExclusion(this, ['viewSold', 'viewUnsold']);
      },
      domReady: function () {
        var productSelectors = this.$.productSelectionGroup.querySelectorAll('input[type=checkbox]');
        for (var i = 0; i < productSelectors.length; i++) {
          if (this.includedProducts.indexOf(productSelectors[i].name) != -1){
              productSelectors[i].setAttribute('checked', 'checked');
          }
        }
      },
      loadSavedState: function () {
        var state = this.storage.getItem(this.localStorageKey);
        if (!state) return false;
        Polymer.extend(this, JSON.parse(state));
        return true;
      },
      saveState: function () {
        if (this.localStorageKey && this.localStorageKey.length > 0) {
          this.storage.setItem(this.localStorageKey, JSON.stringify(this.getState()));
        }
      },
      getState: function () {
        return {
          startDate: this.startDate,
          endDate: this.endDate,
          numberOfDays: this.numberOfDays,
          viewSold: this.viewSold,
          viewUnsold: this.viewUnsold,
          viewRecent: this.viewRecent,
          viewRange: this.viewRange,
          includedProducts: this.includedProducts
        }
      },
      updateEndDateOptions: function (event) {
        this.endDates = this.dates.filter(function (date) {
          return Date.parse(date) >= Date.parse(event.target.value);
        }.bind(this));
        if (Date.parse(this.endDate) < Date.parse(event.target.value)){
          this.endDate = event.target.value;
        }
      },
      toggleProduct: function (event) {
        if (event.target.checked) {
          this.includedProducts.push(event.target.name);
        } else {
          this.includedProducts = this.includedProducts.filter(function (el) {
            return el != event.target.name;
          });
        }
      },
      selectStat: function (event) {
        if (event.target.id == 'viewSold') {
          this.viewSold = true;
          this.viewUnsold = false;
        } else {
          this.viewSold = false;
          this.viewUnsold = true;
        }
      },
      getTimeSpan: function () {
        var timeSpan = {};

        if (this.viewRecent) {
          timeSpan.startDate = this.dates[this.dates.length - this.numberOfDays];
          timeSpan.endDate = this.dates[this.dates.length - 1];
        } else {
          timeSpan.startDate = this.startDate;
          timeSpan.endDate = this.endDate;
        }

        return timeSpan;
      },
      onRefresh: function () {
        this.saveState();
        setTimeout(function () {
          this.fire('refresh', {});
        }.bind(this), 0);
      }
    });
  </script>
</polymer-element>
<polymer-element name="fl-sales-distribution" assetpath="elements/">
  <template>
    <style>
      :host {
        display: block;
      }
      :host > div[layout] {
        height: 100%;
      }
      content {
        flex: 0 0 auto;
      }
    </style>
    <core-ajax auto="" id="ajax" handleas="json" on-core-response="{{onNewData}}"></core-ajax>
    <div layout="" vertical="" center="">
      <content></content>
      <div layout="" horizontal="" start="">
        <google-chart id="pieChart" type="pie"></google-chart>
      </div>
    </div>
  </template>
  <script>
    Polymer('fl-sales-distribution',{
      domReady: function (event) {
        this.storage = document.getElementById('storage');
        this.$.options = this.querySelector('#options');
        this.$.options.addEventListener('refresh', this.refresh.bind(this));

        this.refresh();
      },
      refresh: function () {
        this.getChartData();
        this.redraw();
      },
      getChartData: function () {
        this.chartData = {};

        var timeSpan = this.$.options.getTimeSpan();

        window.salesData.history.forEach(function (report){
          // Check that this product is selected for the report
          if (this.$.options.includedProducts.indexOf(report.flower) == -1) return;
          if (Date.parse(report.date) < Date.parse(timeSpan.startDate)) return;
          if (Date.parse(report.date) > Date.parse(timeSpan.endDate)) return;

          // Init the total for this product if not yet done
          this.chartData[report.flower] = this.chartData[report.flower] || {
            total: 0,
          };

          // Accumulate the total for the requested data
          if (this.$.options.viewSold) {
            this.chartData[report.flower].total += parseInt(report['quantity-sold']);
          } else {
            this.chartData[report.flower].total += parseInt(report['quantity-unsold']);
          }
        }.bind(this));
        return this.chartData;
      },
      redraw: function () {
        var cols = [{label: 'Flower', type: 'string'}, {label: 'Total Sales', type: 'number'}];
        var rows = [];

        Object.keys(this.chartData).map(function (product) {
          rows.push([product, this.chartData[product].total]);
        }.bind(this));

        this.$.pieChart.options.legend = {};
        this.$.pieChart.options.legend.position = 'bottom';
        this.$.pieChart.options.pieHole = 0.4;
        this.$.pieChart.cols = cols;
        this.$.pieChart.rows = rows;

        this.$.pieChart.drawChart();
      }
    });
  </script>
</polymer-element>

<polymer-element name="fl-trends" assetpath="elements/">
  <template>
    <style>
      :host {
        display: block;
      }
      :host > div[layout] {
        height: 100%;
      }
      content {
        flex: 0 0 auto;
      }
    </style>
    <core-ajax auto="" id="ajax" handleas="json" on-core-response="{{onNewData}}"></core-ajax>
    <div layout="" vertical="" center="">
      <content></content>
      <div layout="" horizontal="" start="">
        <google-chart id="chart" type="area"></google-chart>
      </div>
    </div>
  </template>
  <script>
    Polymer('fl-trends',{
      domReady: function (event) {
        this.storage = document.getElementById('storage');
        this.$.options = this.querySelector('#options');
        this.$.options.addEventListener('refresh', this.refresh.bind(this));
        this.refresh();
      },
      refresh: function () {
        this.getChartData();
        this.redraw();
      },
      getChartData: function () {
        // Building chart data in array with this format:
        // [
        //   ['Date', 'Flower1', 'Flower2'],
        //   ['2013',  1000,      400],
        //   ['2014',  1170,      460],
        //   ['2015',  660,       1120],
        //   ['2016',  1030,      540]
        // ]

        var columns = ["Date"].concat(this.$.options.includedProducts);
        var rowsByDate = {};
        this.chartData = [columns];

        var timeSpan = this.$.options.getTimeSpan();

        window.salesData.history.forEach(function (report) {
          if (this.$.options.includedProducts.indexOf(report.flower) == -1) return;
          if (Date.parse(report.date) < Date.parse(timeSpan.startDate)) return;
          if (Date.parse(report.date) > Date.parse(timeSpan.endDate)) return;

          // Create the row if this is the first time this date has been encountered
          if (rowsByDate[report.date] == undefined) {
            rowsByDate[report.date] = new Array(columns.length);
            rowsByDate[report.date][0] = report.date;
          }

          // Add the cell for this report
          if (this.$.options.viewSold) {
              rowsByDate[report.date][columns.indexOf(report.flower)] = parseInt(report['quantity-sold']);
          } else {
            rowsByDate[report.date][columns.indexOf(report.flower)] = parseInt(report['quantity-unsold']);
          }

        }.bind(this));

        // Add the rows to the chart data array in order of date
        Object.keys(rowsByDate).
          sort(function (a, b) { return Date.parse(a) - Date.parse(b) }).
          forEach(function (key){
            this.chartData.push(rowsByDate[key]);
          }.bind(this));
      },
      redraw: function () {
        this.$.chart.options.legend = {};
        this.$.chart.options.legend.position = 'bottom';
        this.$.chart.hAxis = {};
        this.$.chart.hAxis.textPosition = 'out';
        this.$.chart.hAxis.slantedText = true;
        this.$.chart.data = this.chartData;

        this.$.chart.drawChart();
      }
    });
  </script>
</polymer-element>
<polymer-element name="fl-dashboard" assetpath="elements/">
  <template>
    <style>
      :host {
        display: block;
      }
      #noViewsPrompt {
        margin: 20px;
        padding: 20px;
        border-radius: 5px;
        background-color: white;
        text-align: center;
      }
      #noViewsPrompt p,
      #noViewsPrompt ul,
      #noViewsPrompt li {
        margin: 10px 0 0 0;
      }
      .view {
        background-color: white;
        border-style: solid;
        border-width: 1px;
        border-color: rgba(0, 0, 0, .2);
        border-radius: 5px;
        margin: 5px;
        padding: 10px;
        box-shadow: 10px 10px 15px rgba(0, 0, 0, .9);
      }
      .viewHeader img {
        width: 2em;
        height: 2em;
      }
      .viewHeader button {
        margin-left: 5px;
      }
      h1 {
        margin: 0;
        font-size: 1.5em;
      }
      .view .titleEdit {
        display: none;
      }
      .view[editing] .titleEdit {
        display: inline;
      }
      .view[editing] h1 {
        display: none;
      }
      .view fl-report-options {
        display: none;
        margin: 5px;
        padding: 10px;
        border-style: solid;
        border-width: 1px;
        border-color: rgba(0, 0, 0, .3);
        border-radius: 5px;
      }
      .view[editing] fl-report-options {
        display: block;
      }
    </style>
    <template if="{{noViews}}">
      <div id="noViewsPrompt" layout="" vertical="" center="">
        <h1>Your dashboard is empty!</h1>
        <p>
          To get started adding content, open a report from the navigation menu on the left.
        </p>
        <p>
          Once you've configured the data you want to see, just click the "add to dashboard" button.
        </p>
        <p>
          (It looks like this)
        </p>
        <button><img src="images/dash.svg"></button>
      </div>
    </template>

    <div flex="" id="viewWrapper" on-refresh="{{saveViewOptions}}" layout="" horizontal="" start="" start-justified="" wrap="">
      <template repeat="{{ view, i in views }}">
        <div class="view" name="{{view.name}}">
          <div class="viewHeader" layout="" horizontal="">
            <h1>{{view.name}}</h1>
            <div class="titleEdit">Name: <input class="" value="{{view.name}}"></div>
            <div flex=""></div>
            <button on-click="{{toggleEditing}}"><img src="images/options.svg"></button>
            <button on-click="{{removeView}}"><img src="images/close.svg"></button>
          </div>
          <template if="{{ view.element == 'fl-sales-distribution' }}">
            <fl-sales-distribution id="{{'report' + i}}" hideoptions="">
              <fl-report-options id="options" class="{{'options' + i}}" options="{{view.options}}"></fl-report-options>
            </fl-sales-distribution>
          </template>
          <template if="{{ view.element == 'fl-trends' }}">
            <fl-trends id="{{'report' + i}}">
              <fl-report-options id="options" options="{{view.options}}"></fl-report-options>
            </fl-trends>
          </template>
        </div>
      </template>
    </div>

  </template>
  <script>
    Polymer('fl-dashboard',{
      noViews: true,
      views: [],
      ready: function () {
        this.storage = document.getElementById('storage');
        this.loadViews();
        if (this.views.length > 0) this.noViews = false;
      },
      saveViewOptions: function (event) {
        var optionsEl = event.target;
        var viewEl = this.getContainingView(optionsEl);
        var viewName = viewEl.getAttribute('name');
        var view = this.views.filter(function (view) {
          return view.name == viewName;
        })[0];
        view.options = optionsEl.getState();
        this.save();
      },
      toggleEditing: function (event) {
        var viewEl = this.getContainingView(event.target);
        if (viewEl.hasAttribute('editing')) {
          viewEl.removeAttribute('editing');
          this.save();
        } else {
          viewEl.setAttribute('editing', '');
        }
      },
      removeView: function (event) {
        var view = this.getContainingView(event.target);
        var name = view.getAttribute('name');
        this.views = this.views.filter(function (view) {
          return view.name != name;
        });
        if (this.views.length == 0) {
          this.noViews = true;
        }
        this.save();
      },
      getContainingView: function (button) {
        var el = button;
        while (!(el.getAttribute('class') || '').match(/(^|\s)view(\s|$)/)) {
          el = el.parentElement;
        }
        return el;
      },
      loadViews: function () {
        var viewsString = this.storage.getItem('dashboardViews');
        if (viewsString) {
          this.views = JSON.parse(viewsString);
        }
      },
      save: function () {
        this.storage.setItem('dashboardViews', JSON.stringify(this.views));
      }
    });
  </script>
</polymer-element>

<polymer-element name="fl-side-nav" assetpath="elements/">
  <template>
    <style>
      :host {
        background-color: #EFEFEF;
        display: block;
        min-width: 100px;
        margin-right: 5px;
      }
      div[route] {
        cursor: default;
        max-height: 1.5em;
        margin: 0;
        padding: 10px;
        border-bottom-style: solid;
        border-bottom-width: 1px;
        border-bottom-color: rgba(0, 0, 0, .2);
        transition: background-color .5s;
        display: flex;
        flex-flow: columns;
        align-items: center;
      }
      div[route]:hover, div[route][selected] {
        background-color: rgba(0, 0, 0, .2);
      }
      div[route] img, div[route] p {
        flex: 0 0 auto;
        margin: 0 5px 0 0;
        pointer-events: none;
      }
      img {
        width: 20px;
        height: 20px;
      }
    </style>
    <!-- Events are re-targeted once they bubble to the custom element
         Wrapping the p's in this div allows us to see the actual target -->
    <div id="clickScreen">
      <div route="/dashboard">
        <img src="images/dash.svg">
        <p>Dashboard</p>
      </div>
      <div route="/distribution">
        <img src="images/pieChart.svg">
        <p>Distributions</p>
      </div>
      <div route="/trends">
        <img src="images/lineGraph.svg">
        <p>Trends</p>
      </div>
    </div>
  </template>
  <script>
    Polymer('fl-side-nav',{
      ready: function () {
        this.$.clickScreen.addEventListener('click', function (event) {
          var route = event.target.getAttribute('route');
          if (!route) return;

          this.fire('navigate', { route: route });
          for(var i = 0; i < this.$.clickScreen.children.length; i++) {
            this.$.clickScreen.children[i].removeAttribute('selected');
          }
          event.target.setAttribute('selected', '');
        }.bind(this));
      }
    });
  </script>
</polymer-element>
<polymer-element name="fl-layout" assetpath="elements/">
  <template>
    <style>
      :host {
        display: block;
        font-family: helvitica, sans-serif;
        height: 100%;
      }
      app-router {
        overflow: auto;
      }
      #layoutWrapper {
        height: 100%;
        width: 100%;
      }
      fl-side-nav {
        min-width: 200px;
        box-shadow: 0px 0px 20px 10px black;
        overflow: auto;
      }
      .reportLayout {
        min-height: 100%;
        min-width: 1000px;
      }
      .reportBackground {
        min-width: 950px;
        height: 100%;
        background-color: white;
        box-shadow: 0px 0px 20px 10px black;
      }
      .report {
        padding: 10px;
      }
      fl-dashboard {
        min-width: 800px;
      }
      fl-dashboard /deep/ google-chart {
        width: 400px;
        height: 400px;
      }
      .report /deep/ google-chart {
        width: 700px;
        height: 600px;
      }
      :host /deep/ google-chart /deep/ svg > rect {
        fill: none;
      }
      fl-report-options {
        margin: 5px;
        padding: 10px;
        border-style: solid;
        border-width: 1px;
        border-color: rgba(0, 0, 0, .3);
        border-radius: 5px;
        flex: 0 0 auto;
      }
    </style>
    <paper-dialog id="reportNameDialog" backdrop="" autoclosedisabled="">
      <div id="reportNameDialogWrapper" layout="" vertical="">
        <h1>Adding Report to Dashboard</h1>
        <p>(But first, lets give it a name)</p>
        <input id="reportName" value="{{reportName}}">
        <div layout="" horizontal="" center-justified="">
          <button on-click="{{cancelAddToDashboard}}">Cancel</button>
          <button on-click="{{confirmAddToDashboard}}" disabled?="{{reportName.length == 0}}">Ok</button>
        </div>
      </div>
    </paper-dialog>
    <div id="layoutWrapper" layout="" horizontal="">
      <fl-side-nav on-navigate="{{navigate}}"></fl-side-nav>
      <app-router id="mainRouter" flex="" relative="">
        <app-route path="/dashboard">
          <template>
            <fl-dashboard></fl-dashboard>
          </template>
        </app-route>
        <app-route path="/distribution">
          <template>
            <div class="reportLayout" layout="" vertical="" center="">
              <div class="reportBackground">
                <fl-sales-distribution class="report">
                  <fl-report-options id="options" label="Sales Distribution" localstoragekey="salesReportData">
                    <button title="Add to Dashboard" on-click="{{addToDashboard}}"><img src="images/dash.svg"></button>
                  </fl-report-options>
                </fl-sales-distribution>
              </div>
            </div>
          </template>
        </app-route>
        <app-route path="/trends">
          <template>
            <div class="reportLayout" layout="" vertical="" center="">
              <div class="reportBackground">
                <fl-trends class="report">
                  <fl-report-options id="options" label="Trends" localstoragekey="trendsReportState">
                    <button title="Add to Dashboard" on-click="{{addToDashboard}}"><img src="images/dash.svg"></button>
                  </fl-report-options>
                </fl-trends>
              </div>
            </div>
          </template>
        </app-route>
        <app-route path="*" redirect="/dashboard"></app-route>
      </app-router>
    </div>
  </template>
  <script>
    Polymer('fl-layout',{
      reportNameGiven: false,
      ready: function () {
        this.reportName = "";
        this.storage = document.getElementById('storage');
      },
      navigate: function (event) {
        this.$.mainRouter.go(event.detail.route)
      },
      addToDashboard: function (event) {
        this.$.reportNameDialog.toggle();
      },
      cancelAddToDashboard: function () {
        this.reportName = '';
        this.$.reportNameDialog.toggle();
      },
      confirmAddToDashboard: function () {
        this.$.reportNameDialog.toggle();
        var dashboardViews = this.storage.getItem('dashboardViews');
        if (!dashboardViews) {
          dashboardViews = [];
        } else {
          dashboardViews = JSON.parse(dashboardViews);
        }

        dashboardViews.push({
          name: this.reportName,
          element: this.selectFromRoute('.report').nodeName.toLowerCase(),
          options: this.selectFromRoute('#options').getState()
        });

        this.reportName = '';

        this.storage.setItem('dashboardViews', JSON.stringify(dashboardViews));
      },
      selectFromRoute: function (selector) {
        return this.$.mainRouter.querySelector('app-route ' + selector);
      }
    });
  </script>
</polymer-element>
</div>
  <script>
    window.salesData = {};
    salesData.history = [
      {"flower": "tulip", "date": "2/3/2012", "quantity-sold": "20", "quantity-unsold": "10"},
      {"flower": "tulip", "date": "2/4/2012", "quantity-sold": "18", "quantity-unsold": "12"},
      {"flower": "tulip", "date": "2/5/2012", "quantity-sold": "23", "quantity-unsold": "7"},
      {"flower": "tulip", "date": "2/6/2012", "quantity-sold": "15", "quantity-unsold": "20"},
      {"flower": "tulip", "date": "2/7/2012", "quantity-sold": "12", "quantity-unsold": "23"},
      {"flower": "rose", "date": "2/3/2012", "quantity-sold": "50", "quantity-unsold": "40"},
      {"flower": "rose", "date": "2/4/2012", "quantity-sold": "43", "quantity-unsold": "47"},
      {"flower": "rose", "date": "2/5/2012", "quantity-sold": "55", "quantity-unsold": "35"},
      {"flower": "rose", "date": "2/6/2012", "quantity-sold": "70", "quantity-unsold": "20"},
      {"flower": "rose", "date": "2/7/2012", "quantity-sold": "30", "quantity-unsold": "70"},
      {"flower": "dandelion", "date": "2/3/2012", "quantity-sold": "10", "quantity-unsold": "0"},
      {"flower": "dandelion", "date": "2/4/2012", "quantity-sold": "9", "quantity-unsold": "11"},
      {"flower": "dandelion", "date": "2/5/2012", "quantity-sold": "3", "quantity-unsold": "17"},
      {"flower": "dandelion", "date": "2/6/2012", "quantity-sold": "4", "quantity-unsold": "16"},
      {"flower": "dandelion", "date": "2/7/2012", "quantity-sold": "7", "quantity-unsold": "8"}
    ].map(function (record) {
      record.flower = record.flower.slice(0, 1).toUpperCase() + record.flower.slice(1, record.flower.length);
      return record;
    });
    salesData.products = _.uniq(_.pluck(salesData.history, "flower"));
  </script>
  <volatile-storage id="storage"></volatile-storage>
  <fl-layout></fl-layout>


</body></html>